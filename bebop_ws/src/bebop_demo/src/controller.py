#!/usr/bin/env python

from bebop_msgs.msg import Ardrone3PilotingStateFlyingStateChanged
from geometry_msgs.msg import (Twist, TwistStamped, Point, PointStamped,
                               Pose, PoseStamped)
from std_msgs.msg import Bool, Empty, String
from visualization_msgs.msg import Marker, MarkerArray
from bebop_demo.msg import Trigger, Trajectories, Obstacle
from vive_localization.msg import PoseMeas

from bebop_demo.srv import GetPoseEst, ConfigMotionplanner

import rospy
import numpy as np
import scipy.io as io
from scipy.signal import butter, filtfilt
import tf
import tf2_ros
import tf2_geometry_msgs as tf2_geom

from fabulous.color import (highlight_red, highlight_green, highlight_blue,
                            green, yellow, highlight_yellow)


class Controller(object):

    ############################
    # Initialization functions #
    ############################
    def __init__(self):
        """Initialization of Controller object.
        """
        rospy.init_node("controller")

        self.state = "initialization"
        self.state_dict = {"standby": self.hover,
                           "emergency": self.repeat_safety_brake,
                           "take-off": self.take_off_land,
                           "land": self.take_off_land,
                           "omg standby": self.hover,
                           "omg fly": self.omg_fly,
                           "place hex obstacles": self.place_cyl_hex_obst,
                           "place cyl obstacles": self.place_cyl_hex_obst,
                           "place slalom obstacles": self.place_slalom_obst,
                           "place plate obstacles": self.place_plate_obst,
                           "place window obstacles": self.place_window_obst,
                           "configure motionplanner": self.config_mp,
                           "draw path": self.draw_traj,
                           "fly to start": self.fly_to_start,
                           "follow path": self.follow_traj,
                           "undamped spring": self.hover_changed_gains,
                           "viscous fluid": self.hover_changed_gains,
                           "reset PID": self.reset_pid_gains,
                           "drag drone": self.drag_drone,
                           "gamepad flying": self.gamepad_flying,
                           "dodge dyn obst": self.dodge_dyn_obst}

        self._init_params()
        self._init_variables()
        self._marker_setup()

        self._init_vel_model()
        self._init_topics()

        self.tfBuffer = tf2_ros.Buffer()
        self.listener = tf2_ros.TransformListener(self.tfBuffer)

    def _init_vel_model(self):
        '''Initializes model parameters for conversion of desired velocities to
        angle inputs. Discrete time state space model (Ts=0.01s) of the inverted,
        LPF filtered velocity system.
        '''
        Ax = np.array([[1.947, -0.9481],
                       [1.0000, 0.]])
        Ay = np.array([[1.947, -0.9481],
                       [1.0000, 0.]])
        Az = np.array([[0.9391]])

        self.A = np.zeros([5, 5])
        self.A[0:2, 0:2] = Ax
        self.A[2:4, 2:4] = Ay
        self.A[4:5, 4:5] = Az

        self.B = np.zeros([5, 3])
#         self.B[0, 0] = 1
#         self.B[2, 1] = 1
#         self.B[4, 2] = 1
        self.B[0, 0] = 0.0625
        self.B[2, 1] = 0.125
        self.B[4, 2] = 1

        self.C = np.zeros([3, 5])
#         self.C[0, 0:2] = [0.004232, -0.005015]
#         self.C[1, 2:4] = [-0.003704, 0.002797]
#         self.C[2, 4:5] = [-0.0002301]

        # Numerically more stable:
        self.C[0, 0:2] = [-0.04588, 0.0314]
        self.C[1, 2:4] = [-0.07476, 0.06684]
        self.C[2, 4:5] = [-0.003141]

        self.D = np.array([[0.7498, 0.0, 0.0],
                           [0.0, 0.8537, 0.0],
                           [0.0, 0.0, 1.088]])

    def _init_topics(self):
        '''Initializes rostopic Publishers and Subscribers.
        '''
        self.cmd_vel = rospy.Publisher(
            'bebop/cmd_vel', Twist, queue_size=1)
        self.take_off = rospy.Publisher(
            'bebop/takeoff', Empty, queue_size=1)
        self.land = rospy.Publisher(
            'bebop/land', Empty, queue_size=1)
        self._mp_trigger_topic = rospy.Publisher(
            'motionplanner/trigger', Trigger, queue_size=1)
        self.obst_pub = rospy.Publisher(
            'motionplanner/rviz_obst', MarkerArray, queue_size=1)
        self.vhat_vector_pub = rospy.Publisher(
            'motionplanner/vhat_vector', Marker, queue_size=1)
        self.trajectory_desired = rospy.Publisher(
            'motionplanner/desired_path', Marker, queue_size=1)
        self.trajectory_real = rospy.Publisher(
            'motionplanner/real_path', Marker, queue_size=1)
        self.trajectory_drawn = rospy.Publisher(
            'motionplanner/drawn_path', Marker, queue_size=1)
        self.trajectory_smoothed = rospy.Publisher(
            'motionplanner/smoothed_path', Marker, queue_size=1)
        self.current_ff_vel_pub = rospy.Publisher(
            'motionplanner/current_ff_vel', Marker, queue_size=1)
        self.real_input_vector_pub = rospy.Publisher(
            'motionplanner/real_input_vector', Marker, queue_size=1)
        self.draw_room = rospy.Publisher(
            'motionplanner/room_contours', Marker, queue_size=1)
        self.ctrl_state_finish = rospy.Publisher(
            'controller/state_finish', Empty, queue_size=1)
        self.pos_error_pub = rospy.Publisher(
            'controller/position_error', PointStamped, queue_size=1)

        rospy.Subscriber('motionplanner/result', Trajectories,
                         self.get_mp_result)
        rospy.Subscriber('vive_localization/ready', Empty,
                         self.publish_obst_room)
        rospy.Subscriber('ctrl_keypress/rtrigger', Bool, self.r_trigger)
        rospy.Subscriber('ctrl_keypress/ltrigger', Bool, self.l_trigger)
        rospy.Subscriber('ctrl_keypress/rtrackpad', Bool, self.trackpad_press)
        rospy.Subscriber(
            'vive_localization/c1_pose', PoseStamped, self.get_ctrl_r_pos)
        rospy.Subscriber(
            'vive_localization/c2_pose', PoseStamped, self.get_ctrl_l_pos)
        rospy.Subscriber(
            'vive_localization/c1_velocity', TwistStamped, self.get_ctrl_r_vel)
        rospy.Subscriber(
            'vive_localization/c2_velocity', TwistStamped, self.get_ctrl_l_vel)
        rospy.Subscriber('fsm/state', String, self.switch_state)
        rospy.Subscriber(
            '/bebop/states/ardrone3/PilotingState/FlyingStateChanged',
            Ardrone3PilotingStateFlyingStateChanged, self.bebop_flying_state)
        rospy.Subscriber(
            'vive_localization/pose', PoseMeas, self.new_measurement)

    def _init_params(self):
        '''Initializes (reads and sets) externally configurable parameters
        (rosparams).
        '''
        self.Kp_x = rospy.get_param('controller/Kp_x', 0.6864)
        self.Ki_x = rospy.get_param('controller/Ki_x', 0.6864)
        self.Kd_x = rospy.get_param('controller/Kd_x', 0.6864)
        self.Kp_y = rospy.get_param('controller/Kp_y', 0.6864)
        self.Ki_y = rospy.get_param('controller/Ki_y', 0.6864)
        self.Kd_y = rospy.get_param('controller/Kd_y', 0.6864)
        self.Kp_z = rospy.get_param('controller/Kp_z', 0.5)
        self.Ki_z = rospy.get_param('controller/Ki_z', 1.5792)
        self.K_theta = rospy.get_param('controller/K_theta', 0.3)
        self.max_input = rospy.get_param('controller/max_input', 0.5)
        self.max_vel = rospy.get_param('motionplanner/vmax', 0.5)
        self.room_width = rospy.get_param('motionplanner/room_width', 1.)
        self.room_depth = rospy.get_param('motionplanner/room_depth', 1.)
        self.room_height = rospy.get_param('motionplanner/room_height', 1.)
        self.drone_radius = rospy.get_param('motionplanner/drone_radius', 0.20)
        self.safety_treshold = rospy.get_param('controller/safety_treshold',
                                               0.5)
        self.pos_nrm_tol = rospy.get_param(
                                       'controller/goal_reached_pos_tol', 0.05)
        self._sample_time = rospy.get_param('controller/sample_time', 0.01)
        self.omg_update_time = rospy.get_param(
            'controller/omg_update_time', 0.5)
        self.rate = rospy.Rate(1./self._sample_time)

        # Setup low pass filter for trajectory drawing task.
        cutoff_freq_LPF = rospy.get_param('controller/LPF_cutoff', 0.5)
        LPF_order = rospy.get_param('controller/LPF_order', 4)

        norm_fc_LPF = cutoff_freq_LPF/(0.5)*self._sample_time
        self.butter_b, self.butter_a = butter(
            LPF_order, norm_fc_LPF, btype='low', analog=False)

    def _init_variables(self):
        '''Initializes variables that are used later on.
        '''
        # State related variables
        self.airborne = False
        self.calc_succeeded = False
        self.target_reached = False
        self.startup = False
        self.state_changed = False
        self.executing_state = False
        self.state_killed = False
        self.trackpad_held = False
        self.r_trigger_held = False
        self.overtime = False

        # Measurement related variables
        self.meas_pos_x = 0.
        self.meas_pos_y = 0.
        self.meas_pos_z = 0.
        self.meas_time = 0.

        # Drawn path

        self.drawn_pos_x = [-0.2203777691638229, -0.22894261260019455, -0.23822955561138848, -0.24809483410152566, -0.2581352107245358, -0.27109072172102877, -0.2858396608374445, -0.2971004772252992, -0.31314982889871956, -0.3284229389504385, -0.3455821945086761, -0.36130726009868663, -0.37897128703461824, -0.3965823464138012, -0.4182320686446208, -0.43693454517784147, -0.45869970825916484, -0.4792602692768684, -0.49960975059774304, -0.5252852993623156, -0.5475072654995876, -0.5686382912545964, -0.5932377812550862, -0.6165337594290508, -0.6422850165801695, -0.6670108032123272, -0.6949273624708523, -0.7163789142198143, -0.7393491919552537, -0.7661029812812621, -0.7940760766604757, -0.8176686935086499, -0.8443190281249153, -0.8761215654270993, -0.8989282600294639, -0.9273991113477393, -0.9566173838779131, -0.9841947283752885, -1.0173636014039058, -1.0436047799674335, -1.0755021933278863, -1.105501375509693, -1.1362785950459977, -1.1655120947286361, -1.1942437896375377, -1.2275799851554883, -1.2640219983101408, -1.291403606795103, -1.3206373461302405, -1.351216486504705, -1.3822513128716327, -1.4120092105593631, -1.4383247388536846, -1.4668026084555805, -1.4956738451329699, -1.521907360802178, -1.5508231087565338, -1.573610706442527, -1.5960916521565354, -1.623094326190282, -1.6440678099641692, -1.667862636620276, -1.688701849711859, -1.7084985512560413, -1.7282653164011244, -1.7512357962197704, -1.7680753629794337, -1.7843835907552368, -1.800012889446176, -1.8146024682410902, -1.8314284549449642, -1.8418377737194467, -1.85345376041552, -1.862565318569735, -1.8719020657358332, -1.8815595091174373, -1.8882920232782627, -1.895092526830279, -1.9010868233143556, -1.9059467586444123, -1.909577470623633, -1.9122120980860187, -1.9139122990202493, -1.914446936559976, -1.9134124718753815, -1.9105701951050165, -1.9064172725863422, -1.9019054916238476, -1.8956293773305166, -1.8878260346671443, -1.8784219716947552, -1.8683699045969027, -1.8563294506386692, -1.8441165338952148, -1.8310747517299282, -1.817175513041688, -1.802470798971906, -1.7879525807724015, -1.771306881593441, -1.7518764612199735, -1.732279142148955, -1.7134110558153397, -1.693495957224541, -1.6731114413411001, -1.6501400582105976, -1.624554858914201, -1.6033487964391, -1.5816370830933613, -1.5583068386907595, -1.529271203054246, -1.503557505153461, -1.4792012441719375, -1.4517047723215422, -1.4243641453069982, -1.3940909144211213, -1.363061267733361, -1.3323187647940422, -1.3032497017455604, -1.2711133680214655, -1.239677099075596, -1.2064333243740828, -1.1737394893241575, -1.1427718912279534, -1.1093513105914834, -1.075725626402444, -1.0402454408680573, -1.0099443655103695, -0.9810298991916095, -0.9466661134747847, -0.9140250630819118, -0.8802634504387417, -0.8522809244758713, -0.8262674344397776, -0.7966961796200929, -0.7676801423060762, -0.7397288750471889, -0.7124059191079901, -0.6900619072683636, -0.6664511244820379, -0.6394821973737077, -0.6152010924606937, -0.5950595540124564, -0.5727520004593969, -0.5531927802024517, -0.5297708952041207, -0.5078661968029219, -0.4880405526501601, -0.465735775268743, -0.44849746782771893, -0.42743502320166016, -0.40392223536080785, -0.38732719363626256, -0.3682345015983932, -0.3493826156847297, -0.3279651174349443, -0.30560115391225784, -0.28838888892785697, -0.27004528040312703, -0.24989361684632616, -0.23062759170761993, -0.2114579094756488, -0.19461450948184256, -0.17595999113886984, -0.15716726790264524, -0.1380032036377834, -0.12117780939622902, -0.10265013010452684, -0.08722702452091857, -0.0678510294914183, -0.04972452443147013, -0.030415477657877332, -0.013798293307776266, 0.0038842294000001054, 0.021544518370051335, 0.04040713090353032, 0.05710332074417135, 0.0765993136159624, 0.09212051793491183, 0.1107235989850448, 0.13031736388806614, 0.1492787608448909, 0.1678688729671034, 0.18779008942633002, 0.20493441217844843, 0.22561593227893928, 0.24745957329538593, 0.2673318687507935, 0.2864839356418054, 0.3083059364109837, 0.33245351658673794, 0.3583987870415979, 0.3730231607558072, 0.39627584168652774, 0.41428703772736863, 0.43974881710264624, 0.4597307071610972, 0.4832491247440176, 0.502804454410815, 0.524454168236935, 0.5475991206618804, 0.571454150605482, 0.5929159269212243, 0.6138320538990358, 0.6381120140226, 0.6624583453651001, 0.6865977411546083, 0.7103360485873846, 0.7328613671422124, 0.7555442179351988, 0.7782865672969654, 0.8006516292750914, 0.824909445599767, 0.8462448950610331, 0.8705991232486163, 0.8955268726345504, 0.9188343121351026, 0.9443919633879867, 0.9665883116928959, 0.9929367763635697, 1.020147779445402, 1.0453582570474347, 1.069045372705408, 1.0974242048926823, 1.1216185867631308, 1.1515003551203502, 1.1784909682716167, 1.2034806287730524, 1.2314026283803297, 1.258261553369564, 1.2869633182298839, 1.3177029948124679, 1.3448452030113554, 1.370271863941307, 1.3957383582712326, 1.4255749244479712, 1.453085527702613, 1.4788652495938468, 1.5071556771725716, 1.5347600969530604, 1.5618692264896654, 1.5924146071491205, 1.6166615859112918, 1.642364436883473, 1.668301277453998, 1.6926830898401763, 1.7182467145324625, 1.741924002397035, 1.7644668069926845, 1.7893972332109915, 1.8124642290241495, 1.834803998279256, 1.8553326893554627, 1.8746801769583887, 1.8952516624464995, 1.9156033919285493, 1.9321053832063595, 1.9480836629404332, 1.9631642211999363, 1.977546969656636, 1.9920529234696809, 2.0034916286230464, 2.0138083108388907, 2.023604571947733, 2.0308025231870093, 2.038459680039505, 2.043847605514035, 2.0481861854182632, 2.051493879058009, 2.0536983882213384, 2.054947424977822, 2.0554376976952797, 2.0549439500386826, 2.052923920003356, 2.049459390990635, 2.043563513889578, 2.036183565970856, 2.028987048340631, 2.0199272843347282, 2.010212258632161, 1.997743023526101, 1.9843316425077804, 1.972149227859054, 1.958546738082819, 1.9400472247552845, 1.9237733014129321, 1.9066945739549719, 1.8856654481963366, 1.8678889041310023, 1.8487667164182207, 1.8250997339836532, 1.799974529754158, 1.777719767172851, 1.7521724581877147, 1.7270158210134845, 1.6951303639145392, 1.6671761770073852, 1.6386940492279658, 1.6123722269181129, 1.5852153624739485, 1.551480744695703, 1.522761883813169, 1.493530197899664, 1.4633846617079085, 1.4338703303661735, 1.4016621587501752, 1.3706094570643228, 1.3446914257625382, 1.3149634450719074, 1.2866495110556024, 1.2534214451943755, 1.2168922859268116, 1.1923075506859007, 1.157970718183123, 1.1256617701752565, 1.0907470827489218, 1.0581885059637357, 1.0267790018741123, 0.9957426026866005, 0.9632893544510157, 0.9293584768955687, 0.8937102163203059, 0.8674521846143044, 0.8370892226711837, 0.803525184419879, 0.7731665045149558, 0.7415466857896478, 0.71281378501167, 0.6824974125423546, 0.6507962247094969, 0.6235942227949955, 0.5919188136552203, 0.5655438483731787, 0.5386938293722854, 0.5084955182814417, 0.47845421456457826, 0.45373984531440126, 0.42764207893267425, 0.4011746866345609, 0.374522731905528, 0.34668651866653066, 0.32246924411821176, 0.29644300581002003, 0.2725567956971049, 0.2518372471608741, 0.22504784055938432, 0.2022439448894442, 0.17983732000090802, 0.15684085177705542, 0.1343988227818027, 0.11200824719023617, 0.08909155501354471, 0.06722885988016225, 0.04539375052360661, 0.02473247100094289, 0.001584904490827821, -0.02204788735253782, -0.04269823108604731, -0.06588571498333895, -0.08684503004507294, -0.11051117113185738, -0.13276114274494288, -0.15309896709246917, -0.1751035640802372, -0.20034233224391107, -0.21876902113420282, -0.24154972352662796, -0.26100857046627013, -0.2809346621956412, -0.3027791397422881, -0.32609800517731236, -0.3476043111512199, -0.3674331979087002, -0.38763252083478905, -0.4124974412501383, -0.4335529696389169, -0.45476126751771684, -0.47735945990600603, -0.4965564815318957, -0.5189538059489767, -0.5429779195134157, -0.5658962312207159, -0.5870775912034079, -0.6106988587175635, -0.6363403602009168, -0.6595852452374964, -0.6822510375393045, -0.7048125412630526, -0.729273340639419, -0.7539601004844467, -0.7802192077245791, -0.8042932200125561, -0.8258825335514333, -0.8498321299627198, -0.873586620569919, -0.8968992522362242, -0.9221734540730653, -0.9446849833971918, -0.9685756566019972, -0.9936973362780424, -1.016477485176182, -1.041867782042588, -1.0624967182204301, -1.084162931187055, -1.1071289716369836, -1.1266563179191094, -1.1471688396413917, -1.165763805008393, -1.184674976133186, -1.2071127668755706, -1.223420538380549, -1.2413803545682933, -1.2599842739014333, -1.2768407846711245, -1.294493041431056, -1.3138719365960805, -1.3309026255153862, -1.3477209932391396, -1.3637890813603741, -1.3811745348842699, -1.3982554494662311, -1.4135253185047683, -1.4294079538478988, -1.4451217664256717, -1.458679614300956, -1.4738553804701295, -1.4879385774659335, -1.4987361132690866, -1.5105889962588739, -1.5223567138129237, -1.5322772006342786, -1.5446225163392269, -1.5520211759801414, -1.560759060934937, -1.5695930986330664, -1.5764648394268805, -1.5829621863201018, -1.5890593837315778, -1.595287234460379, -1.6010242572482225, -1.6063634862372789, -1.6113021903643618, -1.614775995244849, -1.6182893510893344, -1.6209159485223612]


        self.drawn_pos_y = [0.12121730010169407, 0.12660669678869696, 0.1328798664960702, 0.1397246306235287, 0.14685426988699124, 0.15541818592592915, 0.16462703440875437, 0.17111745097250086, 0.18022525706255665, 0.1889376393933857, 0.19873328647056887, 0.2074777907107137, 0.2174411321975307, 0.22729859368829297, 0.2387647234063952, 0.24887035692127357, 0.2601247505290687, 0.27062190744837666, 0.28072714061710613, 0.29310420599177656, 0.3037795874613516, 0.31361622819846, 0.32472969436801136, 0.3355894581622101, 0.34723475095899436, 0.35865973866131107, 0.3706759963286239, 0.37947384984923316, 0.3884367052660427, 0.39819983010581694, 0.40839393132205615, 0.41661572418056236, 0.4254741273899514, 0.43561268300387823, 0.44184699714285625, 0.44943884842721094, 0.45576158162856206, 0.4607797019439188, 0.46648340626297014, 0.47032363131772414, 0.4751212616211138, 0.47888296902578587, 0.4818615605602532, 0.48433379537033083, 0.4859875461005623, 0.4873925687603533, 0.4873024014896381, 0.48598472020981154, 0.4842601122452299, 0.4805872508167117, 0.4751721816365917, 0.4688133348482273, 0.4611207490113296, 0.45178638728146936, 0.4401377099894759, 0.4279704054995821, 0.4130592394882202, 0.39968490102495235, 0.3853631180258328, 0.36736967109220897, 0.3527559656473882, 0.33498698824712303, 0.3174279471867676, 0.29875064444825195, 0.27885845471401893, 0.25391308194716267, 0.23509434747127855, 0.21455922163439078, 0.19276420227222402, 0.16959372681711904, 0.1392552979272934, 0.11844415325837243, 0.09208810893439212, 0.06936700358651615, 0.04399655023812965, 0.014714456186213809, -0.008496160123971475, -0.033848758944187374, -0.06102570520433215, -0.08839057532742345, -0.1170998558942109, -0.1444851907836291, -0.17502271899725264, -0.2015450168642019, -0.23206856225861827, -0.2623693935072908, -0.2907643019003534, -0.31777204003179094, -0.3476913376233317, -0.37868048324719394, -0.4081903309411823, -0.43498038697010966, -0.463478644948621, -0.4900872880974716, -0.5165970108783187, -0.5426767847832141, -0.56815715683733, -0.5911631752380933, -0.6154365889701476, -0.6416963635004209, -0.6656536483809741, -0.6869237929674883, -0.707668419863984, -0.72743938544144, -0.7468280254942212, -0.7678526989690257, -0.7831896186847591, -0.7988522482532638, -0.8138891451848824, -0.8299470549700807, -0.8429912741386225, -0.8542758002806385, -0.8660084440557876, -0.8762076094224143, -0.8859456172780011, -0.8938630650555592, -0.9001895610060058, -0.9051771322315747, -0.9097141010714469, -0.9132990975094448, -0.9152576269080339, -0.9141962634212262, -0.9119801191363033, -0.9076363120099509, -0.9026510164395125, -0.8961903009177283, -0.889696232502541, -0.8823884893255713, -0.8715940541058109, -0.8606634121155277, -0.848306589354856, -0.8370416285448905, -0.8260968057641671, -0.8125256448840692, -0.7986042800168129, -0.7842245766943701, -0.7695740163901017, -0.7573763240421219, -0.742075063450113, -0.7237541210616003, -0.7053854799263544, -0.6892007757618632, -0.6706899787937237, -0.6542641317541578, -0.6332651370222755, -0.6125814313714475, -0.5926135466383107, -0.5693757353308686, -0.5509761383219738, -0.5286455407624904, -0.5035442201784854, -0.4842415747661186, -0.46178658028993746, -0.4397675788015425, -0.4152959291882823, -0.38965748507200626, -0.3695003029784938, -0.3475344369533153, -0.3225632179232689, -0.2975762069394996, -0.2730208365492941, -0.2519619758721876, -0.22896987398043134, -0.20540432641765438, -0.18036113081067429, -0.15786090746721815, -0.1328249798287191, -0.1116522342158357, -0.08559478778877727, -0.06143974603159874, -0.0367156573364118, -0.015725873799805612, 0.006717195431526379, 0.028856227540002832, 0.052588764596446236, 0.0739631239070011, 0.09748378332554708, 0.11571521509799809, 0.13691143385919702, 0.15817932767286402, 0.17821071929837085, 0.1980917544771441, 0.21901542524451445, 0.23700001298997408, 0.25815906206373174, 0.2797092086370905, 0.2978184715406138, 0.31511966478270903, 0.3352109504634666, 0.3571372819306897, 0.37965828465276386, 0.3921633568434113, 0.41148011626215575, 0.4264782938501557, 0.4471571838259025, 0.46312767493324625, 0.4816995156798096, 0.4973516748634559, 0.514625480296308, 0.5322889116894616, 0.5493269431326435, 0.5640323895704784, 0.5777115256108045, 0.5936497938743819, 0.609482770430315, 0.6247792443766165, 0.6394514253526653, 0.6533673870369741, 0.6670539710057175, 0.6802470155943083, 0.6930848367133438, 0.7064143057000167, 0.7171783441399762, 0.7284715610943211, 0.7384275325140206, 0.7467313314089452, 0.7552751866209784, 0.7617880313598524, 0.7683084086379284, 0.7731723341478418, 0.7765469877814544, 0.7785564313389088, 0.7802997301806289, 0.7811746148800145, 0.781478119209015, 0.780984906478021, 0.7801671525079303, 0.7783510493016961, 0.7757184668720936, 0.7719961090610004, 0.7671468455173465, 0.7624259035918883, 0.7575501159704856, 0.7524575597726266, 0.7451589017987117, 0.737398159736935, 0.7294311455424249, 0.7188331379088861, 0.7064336752763494, 0.6960283635432061, 0.6814359088496922, 0.6678386698198862, 0.6517019889227194, 0.6335817201466116, 0.6146251159568323, 0.5941096830559043, 0.5735333516934498, 0.5534511953388632, 0.5301097578925487, 0.5067436419724438, 0.4818324145463646, 0.45768334805801336, 0.4319978772868638, 0.4027336796534846, 0.370707341212974, 0.34283035708843834, 0.31403664101187645, 0.2846478340388159, 0.2544479050544979, 0.21810343316963232, 0.18588715127213806, 0.15085764289453785, 0.11270589023356559, 0.0805823872864111, 0.0394974189588253, 0.0031237736048845832, -0.03361809063831567, -0.07232013052688635, -0.10708271435590766, -0.145180796395179, -0.18096139055363158, -0.2143212651581723, -0.24722032716931297, -0.28031463279096647, -0.31629501283726835, -0.3536965284992224, -0.3845570789244239, -0.419547365169763, -0.451194461980549, -0.4870358729539044, -0.5202788549182369, -0.5492556062720735, -0.5775223120391817, -0.6112605770855462, -0.6385196992868467, -0.6640783793394172, -0.6931519326961832, -0.716595263950603, -0.738078888100524, -0.7628878492873663, -0.7856193145944963, -0.8045129630553842, -0.8244875737374406, -0.8422548879330383, -0.8643830545651081, -0.8812396618008624, -0.8974069037219938, -0.912490242438798, -0.925684691725762, -0.9421589422033794, -0.9534409377155435, -0.964080212312366, -0.9749932348784549, -0.9841091468735979, -0.9944851993838024, -1.0020464308180568, -1.0080814390945023, -1.0128126694099433, -1.0160618105984738, -1.0193338975821216, -1.0215262848226305, -1.0225226442707482, -1.0229088385679952, -1.0225555232450425, -1.0219496591935169, -1.019999383045365, -1.0170457995219029, -1.0132791022536893, -1.008466843281314, -1.0022078686260243, -0.994644355328401, -0.9878347081932821, -0.9788260958903159, -0.9679518028612359, -0.9564439050883249, -0.9433529949492887, -0.9300360355203057, -0.9151936230446562, -0.8994144407676288, -0.8851904315623513, -0.8671973281548193, -0.851127740343153, -0.8333809414441404, -0.8124783638059365, -0.790041637453204, -0.7713782411788399, -0.7512780262177432, -0.7300796011644648, -0.708028863763067, -0.6836710778454727, -0.6623748453732299, -0.6391316111796286, -0.6177960746577837, -0.5984072342862858, -0.5721511395111523, -0.5485997235389903, -0.5248152298756099, -0.5003528154811914, -0.47650184132409334, -0.4523433276623745, -0.4270298148531677, -0.4031523192798643, -0.379052151246686, -0.35588946879213523, -0.33046766534600946, -0.30448298801226503, -0.28176331703908675, -0.25686232974858614, -0.23424216047082158, -0.20899200616836566, -0.18462295467005774, -0.16203484852794903, -0.1369857059441557, -0.1083443081634734, -0.08796316265945303, -0.06249731599950037, -0.040861336746218724, -0.01844084987722794, 0.0070290564424073665, 0.03438936299230466, 0.059661845607398734, 0.083080722085344, 0.10603274599754253, 0.13429513602261167, 0.15830057306173417, 0.18318145967198096, 0.2085633626423371, 0.2296965505774946, 0.25431655019222066, 0.2803437073513202, 0.3039423247648789, 0.3239686970070337, 0.3446774598286413, 0.36730184485425665, 0.3872987770251375, 0.407419469898225, 0.42664805705891373, 0.4462533714458081, 0.4648999790624566, 0.48314593973877207, 0.49981789441432767, 0.5137373962845508, 0.5290110594856468, 0.544874372155145, 0.5606547382332028, 0.5776420773652493, 0.5915594435856635, 0.6056326635712987, 0.6204390178835308, 0.6336999919659387, 0.6501761538554285, 0.6633091285000012, 0.6769059828475013, 0.6911030328246697, 0.7026737711380802, 0.7148510851792949, 0.7248074362642825, 0.7347157077876514, 0.7465460201252536, 0.7548310822027693, 0.7647282267135289, 0.7746222435436179, 0.7834725857738523, 0.7929542018374911, 0.8030106421554541, 0.8118158833412232, 0.8201558029231448, 0.8283267357353856, 0.837643079942215, 0.8463455751734894, 0.8536699527641063, 0.8603022334299462, 0.8663117831687193, 0.8718752599795201, 0.8778881879416547, 0.8832200206610576, 0.8875952626080621, 0.8915604499969412, 0.8955477639540315, 0.898277226207854, 0.901760334395671, 0.9041994925481303, 0.9064365015992761, 0.9089238835164901, 0.9105371795939559, 0.9119939022231549, 0.9130209686432518, 0.9139745736500133, 0.9155910676761716, 0.9172222774154917, 0.9185347417824938, 0.9200474348816192, 0.9216344918817438, 0.9236880143536066]

        self.drawn_pos_z = [1.2648563947657652, 1.2611696330546889, 1.2571036794465316, 1.2528584335286954, 1.2488314029371008, 1.2445535440736268, 1.2398787360313128, 1.236629729089244, 1.2323753626658414, 1.2285606841041765, 1.2240376247600535, 1.2198940370489242, 1.2150086245889031, 1.2098292266454456, 1.2033091491420236, 1.1980664860508825, 1.1921870488785586, 1.187166876758389, 1.1826235479735805, 1.1771909683483888, 1.173175807553966, 1.1688983661856158, 1.164356578713393, 1.1602014072677147, 1.1549143712318368, 1.1508170580676247, 1.1463168072948653, 1.1427394973679568, 1.138715329874926, 1.133319515481643, 1.1279697421771213, 1.1236306259349007, 1.119708480332838, 1.1147800516878037, 1.111022888362534, 1.1065021972011841, 1.1017804266032918, 1.09747383010353, 1.0920015747549183, 1.0871795587840125, 1.0813389610059096, 1.0756599837677507, 1.0693528407221513, 1.0628135858271184, 1.0552602511716944, 1.0458127954845964, 1.035614076619228, 1.0282097078329875, 1.0201211892158926, 1.0109059947290346, 1.0017810347064882, 0.9933418452274108, 0.9859539843453302, 0.9781458405984893, 0.9703217609601511, 0.9626016390001988, 0.9533280984325891, 0.945441515509758, 0.9380057688926389, 0.929172460073658, 0.9218611424008756, 0.912887937797453, 0.9047750281651661, 0.8968654802924543, 0.8887937786703761, 0.8790012451933067, 0.8715927950513871, 0.8639732659768979, 0.8560248020465346, 0.8485023441798312, 0.8396784473579579, 0.8339054636504799, 0.8279015903257516, 0.8228603414237181, 0.8180622300806673, 0.8127623214216073, 0.8096978532119441, 0.8068698475341538, 0.8030169764811275, 0.7994273528048645, 0.7952358495555942, 0.7912880137946203, 0.787575241606572, 0.78491658036807, 0.7825727767648818, 0.780860215309632, 0.7801576653995124, 0.780389166065866, 0.7814982482065504, 0.7832460404469197, 0.7858006679270693, 0.7885760460591626, 0.7928118243219924, 0.7976187173724232, 0.8034430416821206, 0.8099065737866575, 0.8166504134321095, 0.8235166421887046, 0.8312393730304444, 0.840593775061877, 0.8495853366742732, 0.8583896200211165, 0.8683011162434917, 0.878617721268333, 0.8890469502304839, 0.9007833937072016, 0.9111014929256098, 0.9207673120180275, 0.9318261992834773, 0.9458569154077527, 0.9584827303221639, 0.9701199848173572, 0.9835573477505521, 0.9967367874887594, 1.0115792977440294, 1.0263444516435152, 1.040042419413649, 1.0521038959402997, 1.0647566574353973, 1.0768578844410028, 1.089948696204515, 1.1026966765077606, 1.114683031774699, 1.127712391061381, 1.1400774939263456, 1.1546302049566854, 1.1679279949949577, 1.181040290210197, 1.1968892494446963, 1.211497841566839, 1.2265816919065236, 1.2390803544361964, 1.251072707553865, 1.2648060312143008, 1.2784153506141678, 1.2910592541775259, 1.303262054682301, 1.3135996078061907, 1.3260238219284988, 1.339669633606554, 1.351791066736941, 1.361411643070965, 1.3719696684221272, 1.3809700882160099, 1.3918397656159327, 1.402022654425548, 1.410838209395987, 1.4211005491757802, 1.429125804908342, 1.4386256507789867, 1.4491146784590827, 1.456741913980454, 1.4652250451958415, 1.4733728235615386, 1.481649314441564, 1.4895048460973883, 1.4954825408126184, 1.5022186346527882, 1.5095444858939864, 1.5168542273118715, 1.5231907023222115, 1.528018582247129, 1.5326647876880723, 1.5366784927088015, 1.5405157607096447, 1.543566239928115, 1.5465126006625043, 1.5484221426022635, 1.550057682301434, 1.5511007720919059, 1.5518817186884186, 1.552503844855918, 1.553198025506333, 1.5536102201594124, 1.5535970790003888, 1.5529842035800512, 1.5519880836804905, 1.551035273223379, 1.5493635023889973, 1.5467751407938126, 1.543434165250965, 1.5394594786737243, 1.5347986586772064, 1.5303666259588995, 1.5244746798982325, 1.5179662931537288, 1.5114776470686326, 1.5048281081696548, 1.4969161616764919, 1.487830950863155, 1.4778215141262563, 1.4719872162100816, 1.4620493158044146, 1.4539438755145642, 1.4417857893173986, 1.432029912016713, 1.4202947312459655, 1.4099695325844948, 1.3983220005804484, 1.385936481188982, 1.3733284543447937, 1.3626162817706298, 1.3510922350032004, 1.3377757623228508, 1.3231495525262045, 1.308416299630472, 1.2941824222414637, 1.2796541446188097, 1.2646143096299847, 1.249172358655585, 1.2337716593912569, 1.2175880560691796, 1.2027568246287075, 1.1864412279965695, 1.1700535656482467, 1.154220077614095, 1.1369219411731213, 1.1229966181855908, 1.1068880578777476, 1.0913812438757275, 1.0774669279074374, 1.0641478806740254, 1.0491891451568023, 1.0361078975033906, 1.021238752297757, 1.007840122956013, 0.9953191554002574, 0.9822415984826729, 0.9695675576489584, 0.9564160945999836, 0.9425949970380922, 0.9305942880265847, 0.9194504870323421, 0.9080837568554954, 0.8942243253574476, 0.8807819720212688, 0.8686446616694186, 0.8548014820383434, 0.8394351248679426, 0.8286575487523344, 0.8146551328799467, 0.8028861297216117, 0.7914770009992176, 0.7806528645700448, 0.7718751987196995, 0.7647777959767876, 0.7589601304761859, 0.7548872627677912, 0.7513646409239194, 0.7484409661663816, 0.745655907036189, 0.7442502518020473, 0.7446403460865993, 0.7467569622571495, 0.751231612482643, 0.7560071467127396, 0.7616750589920969, 0.7683008144979273, 0.775969952174655, 0.7863733706632421, 0.7962531897913738, 0.8063378791954636, 0.8178220099503863, 0.8280334091675714, 0.8415700330198175, 0.8545774566079782, 0.8680934542781129, 0.8825375610890263, 0.8965670676847683, 0.9144185990258891, 0.932324922125737, 0.949815844966601, 0.9669856807101742, 0.9849201030428993, 1.0058406787251646, 1.0272643836620772, 1.0448853259046453, 1.0640079704007095, 1.0830935234686858, 1.1038830237337387, 1.1246904588171578, 1.142900781861658, 1.16101690546143, 1.1837930492225244, 1.2020467129677581, 1.2198820964876695, 1.241217196554718, 1.2576021799204453, 1.2754972666867395, 1.2956339275218633, 1.3163974366560687, 1.3339644225250096, 1.3519842410734484, 1.3695115026361677, 1.3884799721294392, 1.4034810228866368, 1.4195236703464142, 1.4325977755137318, 1.4457895239880023, 1.4604304853336834, 1.4720100500663476, 1.4834388347711764, 1.4933118514012633, 1.5033439440119707, 1.513728559789536, 1.5235216735850405, 1.5316395921883021, 1.5400641878662202, 1.5477132378449787, 1.5556343659271457, 1.5638248101801844, 1.568581315084841, 1.5742421519957899, 1.5789236640266133, 1.582754175406841, 1.5856097493779984, 1.5876032434619516, 1.5891559274736586, 1.5891929293796223, 1.5884980877326536, 1.5866814000971845, 1.584569989475084, 1.5818297089665863, 1.5777129548207667, 1.5733504890059102, 1.567671871526398, 1.5619849650683746, 1.5558235217144576, 1.547928214274678, 1.5410454809114498, 1.5326464219104936, 1.5247469659476132, 1.5165334169245253, 1.5064487022648458, 1.4959984691041894, 1.4870401061188103, 1.4772757385739097, 1.4664869662621474, 1.4547091395821459, 1.4418932262923294, 1.4303197104354015, 1.4179173873596334, 1.4068140146817323, 1.3967902348634746, 1.3840148343029148, 1.3725103774012333, 1.361084721677967, 1.3490325608904068, 1.3375071319342031, 1.3255501048795848, 1.3132502349454307, 1.3013338308623978, 1.2885851745794152, 1.2760418618015534, 1.2612652876168102, 1.2461069370033433, 1.2321236377819995, 1.2158210681384396, 1.200905979845206, 1.1841488656339427, 1.1679290543678986, 1.1534110004064981, 1.1377658151431735, 1.120640883717172, 1.10922755866818, 1.0953399464864182, 1.0834620901105863, 1.0717764949023596, 1.0593515615651619, 1.0465401412438553, 1.0349902433486495, 1.02465264644109, 1.014578978954339, 1.0031403951381626, 0.9937422853350446, 0.9845022088087751, 0.9744268641116969, 0.9660896042081211, 0.9572476917879309, 0.9482012142751899, 0.940525749157543, 0.9342172210791844, 0.9284289355919486, 0.923264582357475, 0.9189416585074763, 0.9155778917774522, 0.9122323488935682, 0.9093674702911603, 0.9068320631682205, 0.9047805366920665, 0.9036376760713707, 0.9027671334922585, 0.9023172711939191, 0.9018249031378236, 0.9017021351622696, 0.9014452603190448, 0.9002680285354279, 0.8985531181226611, 0.8963022618129486, 0.8941724424028252, 0.8927462800398052, 0.8916416132887874, 0.890892106987851, 0.8903737682056829, 0.8908849835354886, 0.8927943858646135, 0.8946036937190285, 0.8966634907160742, 0.8993770297244765, 0.9017890565458135, 0.9052291488832684, 0.9089065757139596, 0.9120145916908236, 0.9149874114821197, 0.9185351517655682, 0.9213643933403406, 0.9244117499312499, 0.9278442874343962, 0.9316158549277811, 0.9351116000932465, 0.9381463880649454, 0.9411573108236975, 0.9446121150077733, 0.9481868909672253, 0.9525440256926911, 0.9571131667701815, 0.9608818187653716, 0.9660148633212784, 0.9710557081143008, 0.9753726645727707, 0.9800174689677399, 0.9820818266747646, 0.9851718716653168, 0.9886319137540907, 0.9916989970084948, 0.9936911783330635, 0.9951086146400852, 0.9962005930009694, 0.9964373234039368, 0.9967940192865894, 0.9965326878009619, 0.9963107255340686, 0.9958281609020079, 0.996167911059312]

        # Other
        self._traj = {'u': [0.0], 'v': [0.0], 'w': [0.0],
                      'x': [0.0], 'y': [0.0], 'z': [0.0]}
        self._traj_strg = {'u': [0.0], 'v': [0.0], 'w': [0.0],
                           'x': [0.0], 'y': [0.0], 'z': [0.0]}
        self.X = np.array([[0.0], [0.0], [0.0], [0.0], [0.0]])
        self.desired_yaw = np.pi/2.
        self.real_yaw = 0.0
        self.pos_nrm = np.inf
        self.feedback_cmd_prev = Twist()
        self.pos_error_prev = PointStamped()
        self.vel_error_prev = PointStamped()
        self.measurement_valid = False
        self.static_obst = []
        self.dynamic_obst = []
        self.omg_index = 1
        self.difficult_obst = False
        self._goal = Pose()
        self.hover_setpoint = Pose()
        self.ctrl_r_pos = Pose()
        self.ctrl_r_vel = Twist()
        self.ctrl_l_pos = Pose()
        self.ctrl_l_vel = Twist()
        self.draw = False
        self.drag = False

        self.cmd_twist_convert = TwistStamped()
        self.cmd_twist_convert.header.frame_id = "world_rot"
        self.cmd_twist_convert.header.stamp = rospy.Time.now()
        self.feedforward_cmd = TwistStamped()
        self.drone_vel_est = Point()
        self.drone_pose_est = Pose()

    ##################
    # Main functions #
    ##################

    def start(self):
        '''Configures,
        Starts the controller's periodical loop.
        '''
        self.draw_room_contours()
        self.config_mp()
        print green('----    Controller running     ----')

        while not rospy.is_shutdown():
            if self.state_changed:
                self.state_changed = False
                print yellow(' Controller state changed to: ', self.state)
                self.executing_state = True
                # Execute state function.
                self.state_dict[self.state]()
                self.executing_state = False

                # State has not finished if it has been killed!
                if not self.state_killed:
                    self.ctrl_state_finish.publish(Empty())
                    print yellow('------------------------')
                self.state_killed = False

                # Adjust goal to make sure hover uses PID actions to stay in
                # current place.
                self.cmd_twist_convert.header.stamp = rospy.Time.now()
                (self.drone_pose_est, self.drone_vel_est,
                 self.real_yaw, measurement_valid) = self.get_pose_est()
                self.hover_setpoint.position = self.drone_pose_est.position

            if not self.state == "initialization":
                self.hover()
            self.rate.sleep()

    def config_mp(self):
        '''Configures the motionplanner over ConfigMotionplanner Service
        by loading in the room and static obstacles. Waits for Motionplanner to
        set mp_status to configured.
        '''
        if (self.static_obst and
                (self.static_obst[0].obst_type.data == "window plate" or
                 (self.static_obst[0].obst_type.data == "slalom plate" and
                 len(self.static_obst) >= 3))):
            self.difficult_obst = True
        else:
            self.difficult_obst = False

        rospy.wait_for_service("/motionplanner/config_motionplanner")
        config_success = False
        try:
            config_mp_resp = rospy.ServiceProxy(
                "/motionplanner/config_motionplanner", ConfigMotionplanner)
            config_success = config_mp_resp(
                                          static_obstacles=self.static_obst,
                                          dyn_obstacles=self.dynamic_obst,
                                          difficult_obst=self.difficult_obst)
        except rospy.ServiceException, e:
            print highlight_red('Service call failed: %s') % e
            config_success = False

        rospy.Subscriber('motionplanner/goal', Pose, self.set_omg_goal)

        return config_success

    def set_omg_goal(self, goal):
        '''Sets the goal and fires motionplanner.
        Args:
            goal: Pose
        '''
        if self.state == "omg_fly":
            self.safety_brake()

        self.target_reached = False

        self._time = 0.
        self._new_trajectories = False
        self.overtime_counter = 0

        self.cmd_twist_convert.header.stamp = rospy.Time.now()
        (self.drone_pose_est, self.drone_vel_est,
         self.real_yaw, measurement_valid) = self.get_pose_est()

        if not self.state == "fly to start":
            self.reset_markers()

        self._goal = goal
        # Used to store calculation time of motionplanner.
        self.calc_time = {}
        self.calc_time['time'] = []
        self.fire_motionplanner()

        self._init = True
        self.startup = True

        # print yellow('---- Motionplanner goal set! ----')

    def fire_motionplanner(self):
        '''Publishes inputs to motionplanner via Trigger topic.
        '''
        trigger = Trigger()
        trigger.goal_pos = self._goal
        trigger.goal_vel = Point()
        trigger.pos_state = self.drone_pose_est
        trigger.vel_state = self.drone_vel_est
        trigger.dyn_obstacles = self.dynamic_obst
        trigger.current_time = self._time

        self.fire_time = rospy.get_rostime()

        self._mp_trigger_topic.publish(trigger)

    def get_mp_result(self, data):
        '''Store results of motionplanner calculations.

        Args:
            data : calculated trajectories received from 'mp_result' topic,
                   published by motionplanner.
        '''
        self.store_trajectories(data.u_traj, data.v_traj, data.w_traj,
                                data.x_traj, data.y_traj, data.z_traj,
                                data.success)
        self.receive_time = rospy.get_rostime()
        self.calc_time['time'].append(
                                (self.receive_time - self.fire_time).to_sec())

    def omg_update(self):
        '''
        - Updates the controller with newly calculated trajectories and
        velocity commands.
        - Sends out new velocity command.
        - Retrieves new pose estimate.
        '''
        # Send velocity sample.
        self.cmd_twist_convert.header.stamp = rospy.Time.now()
        self.cmd_vel.publish(self.cmd_twist_convert.twist)

        # Retrieve new pose estimate from World Model.
        # This is a pose estimate for the first following time instance [k+1]
        # if the velocity command sent above corresponds to time instance [k].
        (self.drone_pose_est, self.drone_vel_est, self.real_yaw,
            measurement_valid) = self.get_pose_est()
        self.publish_vhat_vector(self.drone_pose_est.position,
                                 self.drone_vel_est)

        # Publish pose to plot in rviz.
        self.publish_real(self.drone_pose_est.position.x,
                          self.drone_pose_est.position.y,
                          self.drone_pose_est.position.z)

        if not measurement_valid:
            self.safety_brake()
            return
        # Check for new trajectories. While calculating, hover.
        # Trigger Motionplanner or raise 'overtime'
        if self._init:
            if not self._new_trajectories:
                self.hover()
                return
            # Trick to make sure that new trajectories are loaded in next
            # lines of code.
            self.omg_index = int(self.omg_update_time/self._sample_time)
            self._init = False

        if ((self.omg_index >= int(self.omg_update_time/self._sample_time))
                or (self.omg_index >= len(self._traj['u'])-2)):
            if self._new_trajectories:
                # Load fresh trajectories.
                self.load_trajectories()
                self._new_trajectories = False
                self._time += self.omg_index*self._sample_time
                self.pos_index = self.omg_index
                self.omg_index = 1

                # Wait for new set of trajectories when calculation has failed.
                if not self.calc_succeeded:
                    self._init = True
                # Raise overtime counter when calculations were not ready in time.
                if self.overtime:
                    self.overtime_counter += 1
                    self.overtime = False

                # Trigger motion planner.
                self.fire_motionplanner()

            else:
                self.overtime = True
                if self.overtime_counter > 3:
                    self.hover()
                    print highlight_yellow('---- WARNING - OVERTIME  ----')
                return

        # publish current pose and velocity calculated by omg-tools
        pos = PointStamped()
        pos.header.frame_id = "world"
        pos.point = Point(x=self._traj['x'][self.omg_index + 1],
                          y=self._traj['y'][self.omg_index + 1],
                          z=self._traj['z'][self.omg_index + 1])
        vel = TwistStamped()
        vel.header.frame_id = "world"
        vel.twist.linear.x = self._traj['u'][self.omg_index + 1]
        vel.twist.linear.y = self._traj['v'][self.omg_index + 1]
        vel.twist.linear.z = self._traj['w'][self.omg_index + 1]

        self.publish_current_ff_vel(pos, vel)

        # Calculate the desired yaw angle based on the pointing direction of
        # the resulting feedforward velocity vector.
        # self.desired_yaw = np.arctan2(vel.point.y, vel.point.x)

        # Transform feedforward command from frame world to world_rotated.
        self.rotate_vel_cmd(vel)

        # Convert feedforward velocity command to angle input.
        self.convert_vel_cmd()

        # Combine feedback and feedforward commands.
        self.combine_ff_fb(pos, vel)
        self.publish_real_input_vector(
                    self.drone_pose_est.position, self.cmd_twist_convert)

        self.omg_index += 1
        self.hover_setpoint = self.drone_pose_est

    def draw_update(self, index):
        '''
        - Updates the controller with newly calculated trajectories and
        velocity commands.
        - Sends out new velocity command.
        - Retrieves new pose estimate.
        '''
        # Send velocity sample.
        self.cmd_twist_convert.header.stamp = rospy.Time.now()
        self.cmd_vel.publish(self.cmd_twist_convert.twist)

        # Retrieve new pose estimate from World Model.
        # This is a pose estimate for the first following time instance [k+1]
        # if the velocity command sent above corresponds to time instance [k].
        (self.drone_pose_est, self.drone_vel_est, self.real_yaw,
            measurement_valid) = self.get_pose_est()
        self.publish_vhat_vector(self.drone_pose_est.position,
                                 self.drone_vel_est)

        # Publish pose to plot in rviz.
        self.publish_real(self.drone_pose_est.position.x,
                          self.drone_pose_est.position.y,
                          self.drone_pose_est.position.z)

        self.tracking_meas['real_path_x'].append(
                                                self.drone_pose_est.position.x)
        self.tracking_meas['real_path_y'].append(
                                                self.drone_pose_est.position.y)
        self.tracking_meas['real_path_z'].append(
                                                self.drone_pose_est.position.z)

        if not measurement_valid:
            self.safety_brake()
            return

        # publish current pose and velocity calculated by omg-tools
        pos = PointStamped()
        pos.header.frame_id = "world"
        pos.point = Point(x=self.drawn_pos_x[index],
                          y=self.drawn_pos_y[index],
                          z=self.drawn_pos_z[index])
        vel = TwistStamped()
        vel.header.frame_id = "world"
        vel.twist.linear.x = self.drawn_vel_x[index]
        vel.twist.linear.y = self.drawn_vel_y[index]
        vel.twist.linear.z = self.drawn_vel_z[index]

        self.publish_current_ff_vel(pos, vel)

        # Calculate the desired yaw angle based on the pointing direction of
        # the resulting feedforward velocity vector.
        # self.desired_yaw = np.arctan2(vel.point.y, vel.point.x)

        # Transform feedforward command from frame world to world_rotated.
        self.rotate_vel_cmd(vel)

        # Convert feedforward velocity command to angle input.
        self.convert_vel_cmd()

        # Combine feedback and feedforward commands.
        self.combine_ff_fb(pos, vel)
        self.publish_real_input_vector(
                    self.drone_pose_est.position, self.cmd_twist_convert)

    ###################
    # State functions #
    ###################

    def switch_state(self, state):
        '''Switches state according to the general fsm state as received by
        bebop_core.
        '''
        if not (state.data == self.state):
            self.state = state.data
            self.state_changed = True
            # If new state received before old one is finished, kill current state.
            if self.executing_state:
                self.state_killed = True
        else:
            print yellow(' Controller already in the correct state!')
            # self.ctrl_state_finish.publish(Empty())

        # When going to standby, remove markers in Rviz from previous task.
        if state.data == "standby":
            self.reset_markers()

    def hover(self, vel_desired=Twist()):
        '''Drone keeps itself in same location through a PID controller.
        '''
        if self.airborne:
            (self.drone_pose_est, self.drone_vel_est, self.real_yaw,
                measurement_valid) = self.get_pose_est()

            if not measurement_valid:
                self.safety_brake()
                return
            pos_desired = PointStamped()
            pos_desired.point = Point(x=self.hover_setpoint.position.x,
                                      y=self.hover_setpoint.position.y,
                                      z=self.hover_setpoint.position.z)

            feedback_cmd = self.feedbeck(pos_desired, vel_desired)

            self.cmd_twist_convert.twist = feedback_cmd
            self.cmd_twist_convert.header.stamp = rospy.Time.now()
            self.cmd_vel.publish(self.cmd_twist_convert.twist)

    def take_off_land(self):
        '''Function needed to wait when taking of or landing to make sure no
        control inputs are sent out.
        '''
        self.cmd_vel.publish(Twist())
        self.cmd_twist_convert.twist = Twist()

        if self.state == "take-off" and not self.airborne:
            counter = 0
            self.take_off.publish(Empty())
            while not (self.airborne or (counter > 50) or (
                    rospy.is_shutdown() or self.state_killed)):
                counter += 1
                rospy.sleep(0.1)

        elif self.state == "land" and self.airborne:
            io.savemat('../ff_model_check.mat', self.model_meas)
            rospy.sleep(0.1)
            self.land.publish(Empty())
            while self.airborne and (
                    not (rospy.is_shutdown() or self.state_killed)):
                rospy.sleep(0.1)

    def place_cyl_hex_obst(self):
        '''The user places either infinitely long cylindrical obstacles or
        finite hexagonal obstacles using the left controller. Dragging the Vive
        controller determines the radius of the obstacle. Obstacles are saved
        and drawn in rviz.
        '''
        self.static_obst = []
        self.publish_obst_room(Empty)

        print highlight_green(' Drag left controller to place obstacle ')
        while not (rospy.is_shutdown() or self.state_killed):
            if self.state_changed:
                self.state_changed = False
                break
            if self.draw:
                self.static_obst.append(None)
                center = Point(x=self.ctrl_l_pos.position.x,
                               y=self.ctrl_l_pos.position.y,
                               z=self.ctrl_l_pos.position.z/2.)
                while self.draw:
                    edge = Point(x=self.ctrl_l_pos.position.x,
                                 y=self.ctrl_l_pos.position.y,
                                 z=center.z)
                    radius = self.position_diff_norm(edge, center)
                    if self.state == "place cyl obstacles":
                        Sjaaakie = Obstacle(obst_type=String(
                                            data="inf_cylinder"),
                                            shape=[radius],
                                            pose=[center.x, center.y])
                    else:
                        Sjaaakie = Obstacle(obst_type=String(
                                        data="hexagon"),
                                        shape=[radius, 2.*center.z],
                                        pose=[center.x, center.y, center.z])
                    self.static_obst[-1] = Sjaaakie
                    self.publish_obst_room(Empty)
                    self.rate.sleep()
                print highlight_blue(' Obstacle added ')
            self.rate.sleep()

    def place_slalom_obst(self):
        '''The user places slalom obstacles (plate) with the left controller.
        Dragging the Vive controller determines the orientation of the
        obstacle.
        Obstacles are saved and drawn in rviz.
        '''
        self.static_obst = []
        self.publish_obst_room(Empty)

        print highlight_green(
            ' Drag left controller to place and orient obstacle ')

        while not (rospy.is_shutdown() or self.state_killed):
            if self.state_changed:
                self.state_changed = False
                break
            height = self.room_height
            if self.draw:
                self.static_obst.append(None)
                edge = Point(x=self.ctrl_l_pos.position.x,
                             y=self.ctrl_l_pos.position.y,
                             z=height/2.)
                while self.draw:
                    d = self.ctrl_l_pos.position.y
                    self.rate.sleep()
                if d > edge.y:
                    d = 1  # up
                else:
                    d = -1  # down

                edge.y -= d*0.15
                width = self.room_width/2 - d*edge.y
                thickness = 0.15
                center = Point(x=edge.x,
                               y=edge.y+d*(width - thickness)/2.,
                               z=height/2)
                Sjaaakie = Obstacle(obst_type=String(data="slalom plate"),
                                    shape=[height, width, thickness],
                                    pose=[center.x, center.y, center.z],
                                    direction=d,
                                    edge=[edge.x, edge.y, edge.z])

                self.static_obst[-1] = Sjaaakie
                self.publish_obst_room(Empty)
                print highlight_blue(' Obstacle added ')
            self.rate.sleep()

    def place_plate_obst(self):
        '''The user places plate obstacles with the left controller. Pressing
        the Vive controller button defines the upper corner, while dragging the
        controller determines the orientation and other corners of the plate.
        Obstacles are saved and drawn in rviz.
        '''
        self.static_obst = []
        self.publish_obst_room(Empty)

        print highlight_green(
            ' Drag left controller to place and orient obstacle ')

        while not (rospy.is_shutdown() or self.state_killed):
            if self.state_changed:
                self.state_changed = False
                break

            if self.draw:
                self.static_obst.append(None)
                upper_corner = Point(x=self.ctrl_l_pos.position.x,
                                     y=self.ctrl_l_pos.position.y,
                                     z=self.ctrl_l_pos.position.z)
                while self.draw:
                    lower_corner = Point(x=self.ctrl_l_pos.position.x,
                                         y=self.ctrl_l_pos.position.y,
                                         z=self.ctrl_l_pos.position.z)
                    center = Point(x=(upper_corner.x + lower_corner.x)/2.,
                                   y=(upper_corner.y + lower_corner.y)/2.,
                                   z=(upper_corner.z + lower_corner.z)/2.)
                    thickness = 0.1
                    delta_x = upper_corner.x - lower_corner.x
                    delta_y = upper_corner.y - lower_corner.y

                    # Trick to avoid error when delta_x == 0.
                    if delta_x == 0:
                        delta_x = 0.01
                    orientation = np.arctan2((delta_y),
                                             (delta_x)) + np.pi/2.
                    width = np.sqrt(delta_x**2 + delta_y**2)
                    height = upper_corner.z - lower_corner.z
                    Sjaaakie = Obstacle(obst_type=String(data="plate"),
                                        shape=[height, width, thickness],
                                        pose=[center.x, center.y, center.z],
                                        direction=orientation)

                    self.static_obst[-1] = Sjaaakie
                    self.publish_obst_room(Empty)
                    rospy.sleep(0.05)
                print highlight_blue(' Obstacle added ')
            self.rate.sleep()

    def place_window_obst(self):
        '''Place a rectangular window obstacle by defining the center and the
        upper right corner. Windows can only be placed perpendicular to the
        x-direction.
        '''
        self.static_obst = []
        self.publish_obst_room(Empty)

        print highlight_green(
            ' Drag left controller to place obstacle ')

        while not (rospy.is_shutdown() or self.state_killed):
            if self.state_changed:
                self.state_changed = False
                break

            if self.draw:
                for _ in range(0, 4):
                    self.static_obst.append(None)
                corner1 = Point(x=self.ctrl_l_pos.position.x,
                                y=self.ctrl_l_pos.position.y,
                                z=self.ctrl_l_pos.position.z)
                while self.draw:
                    corner2 = Point(x=corner1.x,
                                    y=self.ctrl_l_pos.position.y,
                                    z=self.ctrl_l_pos.position.z)
                    thickness = 0.1

                    center = Point(x=corner1.x,
                                   y=(corner1.y+corner2.y)/2.,
                                   z=(corner1.z+corner2.z)/2.)

                    window_width = abs(corner1.y - corner2.y)
                    window_height = abs(corner1.z - corner2.z)

                    # left
                    w_p1 = self.room_depth/2. + center.y - window_width/2.
                    h_p1 = self.room_height
                    x_p1 = center.x
                    y_p1 = -(self.room_depth - w_p1)/2.
                    z_p1 = self.room_height/2.
                    plate1 = Obstacle(obst_type=String(data="window plate"),
                                      shape=[h_p1, w_p1, thickness],
                                      pose=[x_p1, y_p1, z_p1])
                    # right
                    w_p2 = self.room_depth/2. - (center.y + window_width/2.)
                    h_p2 = self.room_height
                    x_p2 = center.x
                    y_p2 = (self.room_depth - w_p2)/2.
                    z_p2 = self.room_height/2.
                    plate2 = Obstacle(obst_type=String(data="window plate"),
                                      shape=[h_p2, w_p2, thickness],
                                      pose=[x_p2, y_p2, z_p2])
                    # up
                    w_p3 = self.room_depth
                    h_p3 = self.room_height - (center.z + window_height/2.)
                    x_p3 = center.x
                    y_p3 = center.y
                    z_p3 = self.room_height - h_p3/2.
                    plate3 = Obstacle(obst_type=String(data="window plate"),
                                      shape=[h_p3, w_p3, thickness],
                                      pose=[x_p3, y_p3, z_p3])
                    # down
                    w_p4 = self.room_depth
                    h_p4 = center.z - window_height/2.
                    x_p4 = center.x
                    y_p4 = center.y
                    z_p4 = h_p4/2.
                    plate4 = Obstacle(obst_type=String(data="window plate"),
                                      shape=[h_p4, w_p4, thickness],
                                      pose=[x_p4, y_p4, z_p4])

                    self.static_obst[-4] = plate1
                    self.static_obst[-3] = plate2
                    self.static_obst[-2] = plate3
                    self.static_obst[-1] = plate4
                    self.publish_obst_room(Empty)
                    rospy.sleep(0.05)
                print highlight_blue(' Obstacle added ')
            self.rate.sleep()

    def omg_fly(self):
        '''Fly from start to end point using omg-tools as a motionplanner.
        '''
        self.omg_index = 1
        self.set_omg_update_time()
        self.set_ff_pid_gains()

        while not (self.target_reached or (
                rospy.is_shutdown() or self.state_killed)):

            if self.startup:  # Becomes True when goal is set.
                self.omg_update()
                # Determine whether goal has been reached.
                self.check_goal_reached()
            self.rate.sleep()
        self.hover_setpoint = self.drone_pose_est
        self.reset_pid_gains()
        self.startup = False

    def draw_traj(self):
        '''Start building a trajectory according to the trajectory of the
        controller.
        '''
        self.reset_markers()
        print highlight_green('---- Start drawing path with left Vive'
                              ' controller while holding trigger ----')
        self.tracking_meas = {}
        self.tracking_meas['real_path_x'] = []
        self.tracking_meas['real_path_y'] = []
        self.tracking_meas['real_path_z'] = []
        self.stop_drawing = False
        self.draw = True

        while not (self.stop_drawing or (
                rospy.is_shutdown() or self.state_killed)):
            if self.draw:
                # Erase previous markers in Rviz.
                self.reset_markers()

                print yellow('---- Trigger button has been released,'
                             'path will be calculated ----')

                self.draw_ctrl_path()

                # Process the drawn trajectory so the drone is able to follow
                # this path.
                if len(self.drawn_pos_x) > 50:
                    self.diff_interp_traj()
                    self.low_pass_filter_drawn_traj()
                    self.differentiate_traj()
                    self.tracking_meas['drawn_path_x'] = self.drawn_pos_x
                    self.tracking_meas['drawn_path_y'] = self.drawn_pos_y
                    self.tracking_meas['drawn_path_z'] = self.drawn_pos_z
                else:
                    print highlight_red(
                                    ' Path too short, draw a longer path! ')
                self.draw = False

            rospy.sleep(0.1)

    def fly_to_start(self):
        '''Sets goal equal to starting position of trajectory and triggers
        omgtools to fly the drone towards it.
        '''
        # If no path drawn, do nothing.
        if not len(self.drawn_pos_x):
            return

        goal = Pose()
        goal.position.x = self.drawn_pos_x[0]
        goal.position.y = self.drawn_pos_y[0]
        goal.position.z = self.drawn_pos_z[0]

        self.model_meas = {}
        (self.model_meas['in_x'], self.model_meas['in_y'],
         self.model_meas['in_z']) = [], [], []
        (self.model_meas['out_x'], self.model_meas['out_y'],
         self.model_meas['out_z']) = [], [], []
        self.model_meas['time'] = []

        self.set_omg_goal(goal)
        self.omg_fly()

    def follow_traj(self):
        '''Lets the drone fly along the drawn path.
        '''
        # If no path drawn, do nothing.
        if not len(self.drawn_pos_x):
            return

        # Reset omg path markers in Rviz.
        self._desired_path.points = []
        self.trajectory_desired.publish(self._desired_path)
        self._real_path.points = []
        self.trajectory_real.publish(self._real_path)
        self.current_ff_vel.points = [Point(), Point()]
        self.current_ff_vel_pub.publish(self.current_ff_vel)
        self.vhat_vector.points = [Point(), Point()]
        self.vhat_vector_pub.publish(self.vhat_vector)

        self.set_ff_pid_gains()

        # Preparing hover setpoint for when trajectory is completed.
        self._goal = Pose()
        self._goal.position.x = self.drawn_pos_x[-1]
        self._goal.position.y = self.drawn_pos_y[-1]
        self._goal.position.z = self.drawn_pos_z[-1]

        self.hover_setpoint = self._goal
        self.target_reached = False

        self.cmd_twist_convert.twist = Twist()
        self.cmd_twist_convert.twist.linear.x = self.drawn_vel_x[0]
        self.cmd_twist_convert.twist.linear.y = self.drawn_vel_y[0]
        self.cmd_twist_convert.twist.linear.z = self.drawn_vel_z[0]

        index = 1
        while (not self.target_reached and (index < len(self.drawn_vel_x))
               and (not rospy.is_shutdown())):
            if self.state_killed:
                break

            self.draw_update(index)
            index += 1
            # Determine whether goal has been reached.
            if ((len(self.drawn_vel_x) - index) < 100):
                self.check_goal_reached()

            self.rate.sleep()
        io.savemat('../tracking_performance_meas.mat', self.tracking_meas)
        self.reset_pid_gains()

    def drag_drone(self):
        '''Adapts hover setpoint to follow vive right controller when trigger
        is pressed.
        '''
        self.set_ff_pid_gains()
        self.drag_velocity = Twist()
        while not (rospy.is_shutdown() or self.state_killed):
            drag_offset = Point(
                x=(self.drone_pose_est.position.x-self.ctrl_l_pos.position.x),
                y=(self.drone_pose_est.position.y-self.ctrl_l_pos.position.y),
                z=(self.drone_pose_est.position.z-self.ctrl_l_pos.position.z))

            while (self.drag and not (
                                    self.state_killed or rospy.is_shutdown())):
                # When trigger pulled, freeze offset controller-drone and adapt
                # hover position and velocity setpoint, until trigger is
                # released. print yellow('in den drag while, drag = ',
                # self.drag)

                # Position setpoint
                self.hover_setpoint.position = Point(
                    x=max(- (self.room_width/2. - self.drone_radius),
                          min((self.room_width/2. - self.drone_radius),
                              (self.ctrl_l_pos.position.x + drag_offset.x))),
                    y=max(- (self.room_depth/2. - self.drone_radius),
                          min((self.room_depth/2. - self.drone_radius),
                              (self.ctrl_l_pos.position.y + drag_offset.y))),
                    z=max(self.drone_radius * 2,
                          min(self.room_height - self.drone_radius,
                              (self.ctrl_l_pos.position.z + drag_offset.z))))
                # Velocity setpoint
                self.drag_velocity.linear.x = self.ctrl_l_vel.linear.x
                self.drag_velocity.linear.y = self.ctrl_l_vel.linear.y
                self.drag_velocity.linear.z = self.ctrl_l_vel.linear.z

                self.hover(self.drag_velocity)
                self.rate.sleep()

            if self.state_changed:
                self.state_changed = False
                break

            self.hover()
            self.rate.sleep()
        self.reset_pid_gains()

    def hover_changed_gains(self):
        '''Adapts gains for the undamped spring (only Kp) or viscous fluid
        (only Kd) illustration.
        '''
        self.hover_setpoint.position.z = rospy.get_param(
            'controller/standard_height', 1.5)

        if self.state == "undamped spring":
            self.Kp_x = self.Kp_x/2.
            self.Ki_x = 0.
            self.Kd_x = 0.
            self.Kp_y = self.Kp_y/2.
            self.Ki_y = 0.
            self.Kd_y = 0.
            self.Kp_z = self.Kp_z/2.
            self.Ki_z = 0.

        elif self.state == "viscous fluid":
            self.Kp_x = 0.
            self.Ki_x = 0.
            self.Kd_x = self.Kd_x/8.
            self.Kp_y = 0.
            self.Ki_y = 0.
            self.Kd_y = self.Kd_y/8.
            self.Kp_z = self.Kp_z/4.
            self.Ki_z = 0.

        while not (self.state_changed or
                   rospy.is_shutdown() or self.state_killed):
            self.hover()
            self.rate.sleep()

    def set_omg_update_time(self):
        '''Adapts the MPC update rate to the difficulty of the obstacles and
        corresponding computation time.
        '''
        if self.difficult_obst:
            self.omg_update_time = rospy.get_param(
                                        'controller/omg_update_time_slow', 0.5)
            self.pos_nrm_tol = rospy.get_param(
                                   'controller/goal_reached_pos_tol_slow', 0.2)
        else:
            self.omg_update_time = rospy.get_param(
                                             'controller/omg_update_time', 0.5)
            self.pos_nrm_tol = rospy.get_param(
                                       'controller/goal_reached_pos_tol', 0.05)

    def set_ff_pid_gains(self):
        '''Sets pid gains to a lower setting for combination with feedforward
        flight to keep the controller stable.
        '''
        if self.state in {"omg fly", "fly to start"} and self.difficult_obst:
            self.Kp_x = rospy.get_param('controller/Kp_omg_low_x', 0.6864)
            self.Ki_x = rospy.get_param('controller/Ki_omg_low_x', 0.6864)
            self.Kd_x = rospy.get_param('controller/Kd_omg_low_x', 0.6864)
            self.Kp_y = rospy.get_param('controller/Kp_omg_low_y', 0.6864)
            self.Ki_y = rospy.get_param('controller/Ki_omg_low_y', 0.6864)
            self.Kd_y = rospy.get_param('controller/Kd_omg_low_y', 0.6864)
            self.Kp_z = rospy.get_param('controller/Kp_omg_low_z', 0.5)
            self.Ki_z = rospy.get_param('controller/Ki_omg_low_z', 1.5792)

        elif self.state in {"omg fly", "fly to start", "dodge dyn obst"}:
            self.Kp_x = rospy.get_param('controller/Kp_omg_x', 0.6864)
            self.Ki_x = rospy.get_param('controller/Ki_omg_x', 0.6864)
            self.Kd_x = rospy.get_param('controller/Kd_omg_x', 0.6864)
            self.Kp_y = rospy.get_param('controller/Kp_omg_y', 0.6864)
            self.Ki_y = rospy.get_param('controller/Ki_omg_y', 0.6864)
            self.Kd_y = rospy.get_param('controller/Kd_omg_y', 0.6864)
            self.Kp_z = rospy.get_param('controller/Kp_omg_z', 0.5)
            self.Ki_z = rospy.get_param('controller/Ki_omg_z', 1.5792)

        elif self.state in {"follow path", "drag drone"}:
            self.Kp_x = rospy.get_param('controller/Kp_dt_x', 0.6864)
            self.Ki_x = rospy.get_param('controller/Ki_dt_x', 0.6864)
            self.Kd_x = rospy.get_param('controller/Kd_dt_x', 0.6864)
            self.Kp_y = rospy.get_param('controller/Kp_dt_y', 0.6864)
            self.Ki_y = rospy.get_param('controller/Ki_dt_y', 0.6864)
            self.Kd_y = rospy.get_param('controller/Kd_dt_y', 0.6864)
            self.Kp_z = rospy.get_param('controller/Kp_dt_z', 0.5)
            self.Ki_z = rospy.get_param('controller/Ki_dt_z', 1.5792)

    def reset_pid_gains(self):
        '''Resets the PID gains to the rosparam vaules after tasks "undamped
        spring" or "viscous fluid".
        '''
        self.Kp_x = rospy.get_param('controller/Kp_x', 0.6864)
        self.Ki_x = rospy.get_param('controller/Ki_x', 0.6864)
        self.Kd_x = rospy.get_param('controller/Kd_x', 0.6864)
        self.Kp_y = rospy.get_param('controller/Kp_y', 0.6864)
        self.Ki_y = rospy.get_param('controller/Ki_y', 0.6864)
        self.Kd_y = rospy.get_param('controller/Kd_y', 0.6864)
        self.Kp_z = rospy.get_param('controller/Kp_z', 0.5)
        self.Ki_z = rospy.get_param('controller/Ki_z', 1.5792)

    def gamepad_flying(self):
        '''Sets up a ros subscriber to read out the inputs given by the gamepad
        and removes this subscriber when the controller switches states.
        '''
        self.meas = {}
        (self.meas['meas_pos_x'], self.meas['meas_pos_y'],
         self.meas['meas_pos_z']) = [], [], []
        (self.meas['est_pos_x'], self.meas['est_pos_y'],
         self.meas['est_pos_z']) = [], [], []
        (self.meas['est_vel_x'], self.meas['est_vel_y'],
         self.meas['est_vel_z']) = [], [], []
        (self.meas['input_x'], self.meas['input_y'],
         self.meas['input_z']) = [], [], []
        self.meas['meas_time'], self.meas['est_time'] = [], []

        self.meas['meas_pos_x'].append(self.meas_pos_x)
        self.meas['meas_pos_y'].append(self.meas_pos_y)
        self.meas['meas_pos_z'].append(self.meas_pos_z)
        self.meas['meas_time'].append(self.meas_time)

        self.gamepad_input = rospy.Subscriber('bebop/cmd_vel',
                                              Twist, self.retrieve_gp_input)

        while not (rospy.is_shutdown() or self.state_killed):
            if self.state_changed:
                self.state_changed = False
                break
            rospy.sleep(0.1)
        self.gamepad_input.unregister()
        print 'length of meas', len(self.meas['meas_pos_x'])
        io.savemat('../kalman_check.mat', self.meas)

    def dodge_dyn_obst(self):
        '''Uses OMG-tools to dodge a moving obstacle coming towards the drone
        and returns back to original position when possible.

        dikke straal aanpassen
        dyn obst in omg-tools steken
        hard term constraint op false?

        '''
        radius = 0.75
        self.dynamic_obst = [Obstacle(obst_type=String(
                            data="inf_cylinder"),
                            shape=[radius],
                            pose=[self.ctrl_r_pos.position.x,
                                  self.ctrl_r_pos.position.y],
                            velocity=[self.ctrl_r_vel.linear.x,
                                      self.ctrl_r_vel.linear.y])]
        self.static_obst = []
        self.config_mp()
        self.set_omg_goal(self.drone_pose_est)
        self.omg_index = 1
        self.set_omg_update_time()
        self.set_ff_pid_gains()

        while not (self.state_changed or (
                rospy.is_shutdown() or self.state_killed)):
            # Becomes True when goal is set.
            if self.startup:
                # Update dynamic obstacle info for when motionplanner is fired.
                self.dynamic_obst = [Obstacle(obst_type=String(
                                      data="inf_cylinder"),
                                      shape=[radius],
                                      pose=[self.ctrl_r_pos.position.x,
                                            self.ctrl_r_pos.position.y],
                                      velocity=[self.ctrl_r_vel.linear.x,
                                                self.ctrl_r_vel.linear.y])]
                self.omg_update()
            self.rate.sleep()
        self.dynamic_obst = []
        self.config_mp()
        self.hover_setpoint = self.drone_pose_est
        self.reset_pid_gains()
        if not self.state_killed:
            self.state_changed = False
        self.startup = False

    ####################
    # Helper functions #
    ####################

    def check_goal_reached(self):
        '''Determines whether goal is reached.
        Returns:
            not stop: boolean whether goal is reached. If not, controller
                      proceeds to goal.
        '''
        pos_nrm = self.position_diff_norm(self.drone_pose_est.position,
                                          self._goal.position)

        self.target_reached = (pos_nrm < self.pos_nrm_tol)
        if self.target_reached:
            io.savemat('../mpc_calc_time.mat', self.calc_time)
            print yellow('=========================')
            print yellow('==== Target Reached! ====')
            print yellow('=========================')

    def rotate_vel_cmd(self, vel):
        '''Transforms the velocity commands from the global world frame to the
        rotated world frame world_rot.
        '''
        self.feedforward_cmd = self.transform_twist(vel, "world", "world_rot")

    def convert_vel_cmd(self):
        '''Converts a velocity command to a desired input angle according to
        the state space representation of the inverse velocity model.
        '''
        u = np.array([[self.feedforward_cmd.twist.linear.x],
                      [self.feedforward_cmd.twist.linear.y],
                      [self.feedforward_cmd.twist.linear.z]])
        print 'input to drone model', self.feedforward_cmd.twist.linear

        self.model_meas['in_x'].append(self.feedforward_cmd.twist.linear.x)
        self.model_meas['in_y'].append(self.feedforward_cmd.twist.linear.y)
        self.model_meas['in_z'].append(self.feedforward_cmd.twist.linear.z)

        self.X = np.matmul(self.A, self.X) + np.matmul(self.B, u)
        Y = np.matmul(self.C, self.X) + np.matmul(self.D, u)
        self.feedforward_cmd.twist.linear.x = Y[0, 0]
        self.feedforward_cmd.twist.linear.y = Y[1, 0]
        self.feedforward_cmd.twist.linear.z = Y[2, 0]
        print 'OUT FROM drone model', self.feedforward_cmd.twist.linear
        self.model_meas['out_x'].append(self.feedforward_cmd.twist.linear.x)
        self.model_meas['out_y'].append(self.feedforward_cmd.twist.linear.y)
        self.model_meas['out_z'].append(self.feedforward_cmd.twist.linear.z)
        self.model_meas['time'].append(rospy.get_time())

    def combine_ff_fb(self, pos_desired, vel_desired):
        '''Combines the feedforward and feedback commands to generate the full
        input angle command.
        '''
        # Transform feedback desired position and velocity from world frame to
        # world_rot frame
        feedback_cmd = self.feedbeck(pos_desired, vel_desired.twist)

        # self.cmd_twist_convert.twist.linear.x = max(min((
        #                 self.feedforward_cmd.linear.x + feedback_cmd.linear.x),
        #                 self.max_input), - self.max_input)
        # self.cmd_twist_convert.twist.linear.y = max(min((
        #                 self.feedforward_cmd.linear.y + feedback_cmd.linear.y),
        #                 self.max_input), - self.max_input)
        # self.cmd_twist_convert.twist.linear.z = max(min((
        #                 self.feedforward_cmd.linear.z + feedback_cmd.linear.z),
        #                 self.max_input), - self.max_input)
        # self.cmd_twist_convert.twist.angular.z = max(min((
        #             self.feedforward_cmd.angular.z + feedback_cmd.angular.z),
        #             self.max_input), - self.max_input)

        self.cmd_twist_convert.twist.linear.x = max(min((
                        self.feedforward_cmd.twist.linear.x),
                        self.max_input), - self.max_input)
        self.cmd_twist_convert.twist.linear.y = max(min((
                        self.feedforward_cmd.twist.linear.y),
                        self.max_input), - self.max_input)
        self.cmd_twist_convert.twist.linear.z = max(min((
                        self.feedforward_cmd.twist.linear.z),
                        self.max_input), - self.max_input)
        self.cmd_twist_convert.twist.angular.z = max(min((
                    self.feedforward_cmd.twist.angular.z),
                    self.max_input), - self.max_input)

    def feedbeck(self, pos_desired, vel_desired):
        '''Whenever the target is reached, apply position feedback to the
        desired end position to remain in the correct spot and compensate for
        drift.
        Tustin discretized PID controller for x and y, PI for z.
        '''
        feedback_cmd = Twist()

        if ((self.state == "undamped spring") or
           (self.state == "viscous fluid")):
            # # PD
            pos_error = PointStamped()
            pos_error.header.frame_id = "world"
            pos_error.point.x = (pos_desired.point.x -
                                 self.drone_pose_est.position.x)
            pos_error.point.y = (pos_desired.point.y -
                                 self.drone_pose_est.position.y)
            pos_error.point.z = (pos_desired.point.z -
                                 self.drone_pose_est.position.z)

            vel_error = PointStamped()
            vel_error.header.frame_id = "world"
            vel_error.point.x = vel_desired.linear.x - self.drone_vel_est.x
            vel_error.point.y = vel_desired.linear.y - self.drone_vel_est.y

            pos_error = self.transform_point(pos_error, "world", "world_rot")
            vel_error = self.transform_point(vel_error, "world", "world_rot")

            feedback_cmd.linear.x = max(- self.max_input, min(self.max_input, (
                    self.Kp_x*pos_error.point.x +
                    self.Kd_x*vel_error.point.x)))
            feedback_cmd.linear.y = max(- self.max_input, min(self.max_input, (
                    self.Kp_y*pos_error.point.y +
                    self.Kd_y*vel_error.point.y)))
            feedback_cmd.linear.z = max(- self.max_input, min(self.max_input, (
                    self.Kp_z*pos_error.point.z)))
        else:
            # # PID
            pos_error_prev = self.pos_error_prev
            pos_error = PointStamped()
            pos_error.header.frame_id = "world"
            pos_error.point.x = (pos_desired.point.x
                                 - self.drone_pose_est.position.x)
            pos_error.point.y = (pos_desired.point.y
                                 - self.drone_pose_est.position.y)
            pos_error.point.z = (pos_desired.point.z
                                 - self.drone_pose_est.position.z)

            vel_error_prev = self.vel_error_prev
            vel_error = PointStamped()
            vel_error.header.frame_id = "world"
            vel_error.point.x = vel_desired.linear.x - self.drone_vel_est.x
            vel_error.point.y = vel_desired.linear.y - self.drone_vel_est.y

            pos_error = self.transform_point(pos_error, "world", "world_rot")
            vel_error = self.transform_point(vel_error, "world", "world_rot")

            feedback_cmd.linear.x = max(- self.max_input, min(self.max_input, (
                    self.feedback_cmd_prev.linear.x +
                    (self.Kp_x + self.Ki_x*self._sample_time/2) *
                    pos_error.point.x +
                    (-self.Kp_x + self.Ki_x*self._sample_time/2) *
                    pos_error_prev.point.x +
                    self.Kd_x*(vel_error.point.x - vel_error_prev.point.x))))

            feedback_cmd.linear.y = max(- self.max_input, min(self.max_input, (
                    self.feedback_cmd_prev.linear.y +
                    (self.Kp_y + self.Ki_y*self._sample_time/2) *
                    pos_error.point.y +
                    (-self.Kp_y + self.Ki_y*self._sample_time/2) *
                    pos_error_prev.point.y +
                    self.Kd_y*(vel_error.point.y - vel_error_prev.point.y))))

            feedback_cmd.linear.z = max(- self.max_input, min(self.max_input, (
                    self.feedback_cmd_prev.linear.z +
                    (self.Kp_z + self.Ki_z*self._sample_time/2) *
                    pos_error.point.z +
                    (-self.Kp_z + self.Ki_z*self._sample_time/2) *
                    pos_error_prev.point.z)))

        # Add theta feedback to remain at zero yaw angle
        angle_error = ((((self.desired_yaw - self.real_yaw) -
                         np.pi) % (2*np.pi)) - np.pi)
        # print 'desired yaw angle', self.desired_yaw
        # print 'real yaw angle', self.real_yaw
        # print 'angle error', angle_error
        K_theta = self.K_theta + (np.pi - abs(angle_error))/np.pi*0.2
        # print 'K_theta', K_theta
        feedback_cmd.angular.z = (K_theta*angle_error)
        # feedback_cmd.angular.z = (self.K_theta*angle_error)

        self.pos_error_prev = pos_error
        self.vel_error_prev = vel_error
        self.feedback_cmd_prev = feedback_cmd

        # Publish the position error.
        self.pos_error_pub.publish(pos_error)

        return feedback_cmd

    def safety_brake(self):
        '''Brake as emergency measure: Bebop brakes automatically when
            /bebop/cmd_vel topic receives all zeros.
        '''
        self.cmd_twist_convert.twist = Twist()
        self.cmd_vel.publish(self.cmd_twist_convert.twist)

    def repeat_safety_brake(self):
        '''More permanent emergency measure: keep safety braking until new task
        (eg. land) is given.
        '''
        while not (rospy.is_shutdown() or self.state_killed):
            self.safety_brake()
            self.rate.sleep()

    def get_pose_est(self):
        '''Retrieves a new pose estimate from world model.
        '''
        # This service is provided as soon as vive is ready. (See bebop_test)
        rospy.wait_for_service("/world_model/get_pose")
        try:
            pose_est = rospy.ServiceProxy(
                "/world_model/get_pose", GetPoseEst)
            resp = pose_est(self.cmd_twist_convert)

            yhat = resp.pose_est.point
            pose = Pose()
            pose.position.x = yhat.x
            pose.position.y = yhat.y
            pose.position.z = yhat.z

            vhat = resp.vel_est.point
            yaw = resp.yaw
            measurement_valid = resp.measurement_valid

            return pose, vhat, yaw, measurement_valid

        except rospy.ServiceException, e:
            print highlight_red('Service call failed: %s') % e
            return

    def load_trajectories(self):
        self._traj['u'] = self._traj_strg['u'][:]
        self._traj['v'] = self._traj_strg['v'][:]
        self._traj['w'] = self._traj_strg['w'][:]
        self._traj['x'] = self._traj_strg['x'][:]
        self._traj['y'] = self._traj_strg['y'][:]
        self._traj['z'] = self._traj_strg['z'][:]

    def store_trajectories(self, u_traj, v_traj, w_traj,
                           x_traj, y_traj, z_traj, success):
        '''Stores the trajectories and indicate that new trajectories have
        been calculated.

        Args:
            u_traj : trajectory speed in z-direction
            v_traj : trajectory speed in x-direction
            w_traj : trajectory speed in y-direction
            x_traj : trajectory position in x-direction
            y_traj : trajectory position in y-direction
            z_traj : trajectory position in z-direction
        '''
        self._traj_strg = {}
        self._traj_strg = {'u': u_traj, 'v': v_traj, 'w': w_traj,
                           'x': x_traj, 'y': y_traj, 'z': z_traj}
        self._new_trajectories = True
        self.calc_succeeded = success

        x_traj = self._traj_strg['x'][:]
        y_traj = self._traj_strg['y'][:]
        z_traj = self._traj_strg['z'][:]
        self.publish_desired(x_traj, y_traj, z_traj)

    def transform_twist(self, twist, _from, _to):
        '''Transforms twist (geometry_msgs/Twist) from frame "_from" to
        frame "_to".
        Arguments:
            - _from, _to = string, name of frame
        '''
        cmd_vel = PointStamped()
        cmd_vel.header = twist.header
        cmd_vel.point = twist.twist.linear
        cmd_vel_rotated = self.transform_point(cmd_vel, _from, _to)

        twist_rotated = TwistStamped()
        twist_rotated.header.stamp = twist.header.stamp
        twist_rotated.twist.linear = cmd_vel_rotated.point

        return twist_rotated

    def transform_point(self, point, _from, _to):
        '''Transforms point from _from frame to _to frame.
        '''
        transform = self.tfBuffer.lookup_transform(
            _to, _from, rospy.Time(0), rospy.Duration(0.1))
        point_transformed = tf2_geom.do_transform_point(point, transform)

        return point_transformed

    def get_ctrl_r_pos(self, ctrl_pose):
        '''Retrieves the position of the right hand controller.
        '''
        self.ctrl_r_pos = ctrl_pose.pose

    def get_ctrl_r_vel(self, ctrl_vel):
        '''Retrieves the velocity of the right hand controller.
        '''
        self.ctrl_r_vel = ctrl_vel.twist

    def get_ctrl_l_pos(self, ctrl_pose):
        '''Retrieves the position of the left hand controller and executes
        drawing when trigger is pressed.
        '''
        self.ctrl_l_pos = ctrl_pose.pose
        if (self.state == 'draw path' and self.draw):
            self.draw_ctrl_path()

    def get_ctrl_l_vel(self, ctrl_vel):
        '''Retrieves the velocity of the right hand controller.
        '''
        self.ctrl_l_vel = ctrl_vel.twist

    def trackpad_press(self, trackpad_pressed):
        '''If state is equal to state in list and trackpad is pressed,
        set self.state_changed to true to switch states.
        '''
        if trackpad_pressed.data and not self.trackpad_held:
            if (self.state == "draw path"):
                self.stop_drawing = True
            elif (self.state in {"drag drone",
                                 "viscous fluid",
                                 "undamped spring",
                                 "place hex obstacles",
                                 "place cyl obstacles",
                                 "place slalom obstacles",
                                 "place plate obstacles",
                                 "place window obstacles",
                                 "gamepad flying",
                                 "dodge dyn obst"}):
                self.state_changed = True
            self.trackpad_held = True

        elif not trackpad_pressed.data and self.trackpad_held:
            self.trackpad_held = False

    def r_trigger(self, button_pushed):
        '''When button is pushed on the right hand controller, depending on the
        current state, either sets goal to be equal to the position of the
        controller.
        '''

        if (((self.state == "omg fly") or (self.state == "omg standby"))
           and button_pushed.data and not self.r_trigger_held):
            self.target_reached = False
            goal = Pose()
            goal.position.x = self.ctrl_r_pos.position.x
            goal.position.y = self.ctrl_r_pos.position.y
            goal.position.z = self.ctrl_r_pos.position.z
            self.set_omg_goal(goal)
            self.r_trigger_held = True

        elif (not button_pushed.data and self.r_trigger_held):
            self.r_trigger_held = False

    def l_trigger(self, button_pushed):
        '''When button is pushed on the left hand controller, depending on the
        current state, allows path that the controller describes to be saved or
        enables dragging of the drone.
        '''

        if self.state == "draw path":
            # Start drawing and saving path
            if (button_pushed.data and not self.draw):
                self.drawn_pos_x = []
                self.drawn_pos_y = []
                self.drawn_pos_z = []
                self.draw = True
                print highlight_blue(' Drawing ... ')

            if (not button_pushed.data and self.draw):
                self.draw = False

        elif self.state == "drag drone":
            if (button_pushed.data and not self.drag):
                self.drag = True
            elif (not button_pushed.data and self.drag):
                self.drag = False

        if (self.state in {"place cyl obstacles",
                           "place slalom obstacles",
                           "place hex obstacles",
                           "place plate obstacles",
                           "place window obstacles"}):

            if (button_pushed.data and not self.draw):
                self.draw = True
            if (not button_pushed.data and self.draw):
                self.draw = False

    def bebop_flying_state(self, flying_state):
        '''Checks whether the drone is standing on the ground or flying and
        changes the self.airborne variable accordingly.
        '''
        if flying_state.state == 0:
            self.airborne = False
        elif flying_state.state == 2:
            self.airborne = True

    def diff_interp_traj(self):
        '''Differentiate and interpolate obtained trajectory to obtain
        feedforward velocity commands.
        '''
        self.differentiate_traj()

        # Search for the highest velocity in the trajectory to determine the
        # step size needed for interpolation.
        highest_vel = max(max(self.drawn_vel_x),
                          max(self.drawn_vel_y),
                          max(self.drawn_vel_z))
        self.interpolate_drawn_traj(self.max_vel/highest_vel)

    def differentiate_traj(self):
        '''Numerically differentiates position traject to recover a list of
        feedforward velocities.
        '''
        self.drawn_vel_x = np.diff(self.drawn_pos_x)/self._sample_time
        self.drawn_vel_y = np.diff(self.drawn_pos_y)/self._sample_time
        self.drawn_vel_z = np.diff(self.drawn_pos_z)/self._sample_time

    def interpolate_drawn_traj(self, step):
        '''Linearly interpolates a list so that it contains the desired amount
        of elements where the element distance is equal to step.
        '''
        self.drawn_pos_x = np.interp(np.arange(0, len(self.drawn_pos_x), step),
                                     range(len(self.drawn_pos_x)),
                                     self.drawn_pos_x).tolist()
        self.drawn_pos_y = np.interp(np.arange(0, len(self.drawn_pos_y), step),
                                     range(len(self.drawn_pos_y)),
                                     self.drawn_pos_y).tolist()
        self.drawn_pos_z = np.interp(np.arange(0, len(self.drawn_pos_z), step),
                                     range(len(self.drawn_pos_z)),
                                     self.drawn_pos_z).tolist()

    def low_pass_filter_drawn_traj(self):
        '''Low pass filter the trajectory drawn with the controller in order to
        be suitable for the drone to track it.
        '''
        self.drawn_pos_x = filtfilt(
            self.butter_b, self.butter_a, self.drawn_pos_x, padlen=50)
        self.drawn_pos_y = filtfilt(
            self.butter_b, self.butter_a, self.drawn_pos_y, padlen=50)
        self.drawn_pos_z = filtfilt(
            self.butter_b, self.butter_a, self.drawn_pos_z, padlen=50)

        # Plot the smoothed trajectory in Rviz.
        self.draw_smoothed_path()

    def position_diff_norm(self, point1, point2):
        '''Returns the norm of the difference vector between two given points.
        point1 and point2 are geometry_msgs/Point objects.
        '''
        norm = np.linalg.norm(np.array([point1.x, point1.y, point1.z])
                              - np.array([point2.x, point2.y, point2.z]))
        return norm

    def retrieve_gp_input(self, gp_input):
        '''Reads out the commands sent by the gamepad and sends these to the
        kalman filter to update the state estimation.
        '''
        self.cmd_twist_convert.twist.linear = gp_input.linear
        self.cmd_twist_convert.header.stamp = rospy.get_rostime()
        (self.drone_pose_est, self.drone_vel_est, self.real_yaw,
            measurement_valid) = self.get_pose_est()
        self.publish_vhat_vector(self.drone_pose_est.position,
                                 self.drone_vel_est)

        # Saves data to be able to compare the velocity estimation to the
        # numerically differentiated velocity afterward.
        self.meas['est_pos_x'].append(self.drone_pose_est.position.x)
        self.meas['est_pos_y'].append(self.drone_pose_est.position.y)
        self.meas['est_pos_z'].append(self.drone_pose_est.position.z)
        self.meas['est_vel_x'].append(self.drone_vel_est.x)
        self.meas['est_vel_y'].append(self.drone_vel_est.y)
        self.meas['est_vel_z'].append(self.drone_vel_est.z)
        self.meas['est_time'].append(rospy.get_time())
        self.meas['input_x'].append(self.cmd_twist_convert.twist.linear.x)
        self.meas['input_x'].append(self.cmd_twist_convert.twist.linear.y)
        self.meas['input_x'].append(self.cmd_twist_convert.twist.linear.z)

        if self.meas['meas_time'][-1] != self.meas_time:
            self.meas['meas_pos_x'].append(self.meas_pos_x)
            self.meas['meas_pos_y'].append(self.meas_pos_y)
            self.meas['meas_pos_z'].append(self.meas_pos_z)
            self.meas['meas_time'].append(self.meas_time)

    def new_measurement(self, data):
        '''Reads out vive pose and saves this data when flying with the gamepad.
        '''
        if (self.state == "gamepad flying"):
            self.meas_pos_x = data.meas_world.pose.position.x
            self.meas_pos_y = data.meas_world.pose.position.y
            self.meas_pos_z = data.meas_world.pose.position.z
            self.meas_time = rospy.get_time()

    #######################################
    # Functions for plotting Rviz markers #
    #######################################

    def _marker_setup(self):
        '''Setup markers to display the desired and real path of the drone in
        rviz, along with the current position in the omg-tools generated
        position list.
        '''
        # Obstacles
        self.rviz_obst = MarkerArray()

        # Desired path
        self._desired_path = Marker()
        self._desired_path.header.frame_id = 'world'
        self._desired_path.ns = "trajectory_desired"
        self._desired_path.id = 0
        self._desired_path.type = 4  # Line List.
        self._desired_path.action = 0
        self._desired_path.scale.x = 0.03
        self._desired_path.color.r = 1.0
        self._desired_path.color.g = 0.0
        self._desired_path.color.b = 0.0
        self._desired_path.color.a = 1.0
        self._desired_path.lifetime = rospy.Duration(0)

        self.pos_index = 0
        self.old_len = 0

        # Real path
        self._real_path = Marker()
        self._real_path.header.frame_id = 'world'
        self._real_path.ns = "trajectory_real"
        self._real_path.id = 1
        self._real_path.type = 4  # Line List.
        self._real_path.action = 0
        self._real_path.scale.x = 0.03
        self._real_path.color.r = 0.0
        self._real_path.color.g = 1.0
        self._real_path.color.b = 0.0
        self._real_path.color.a = 1.0
        self._real_path.lifetime = rospy.Duration(0)

        # feedforward position and velocity
        self.current_ff_vel = Marker()
        self.current_ff_vel.header.frame_id = 'world'
        self.current_ff_vel.ns = "current_ff_vel"
        self.current_ff_vel.id = 2
        self.current_ff_vel.type = 0  # Arrow
        self.current_ff_vel.action = 0
        self.current_ff_vel.scale.x = 0.06  # shaft diameter
        self.current_ff_vel.scale.y = 0.1  # head diameter
        self.current_ff_vel.scale.z = 0.15  # head length
        self.current_ff_vel.color.r = 0.0
        self.current_ff_vel.color.g = 0.0
        self.current_ff_vel.color.b = 1.0
        self.current_ff_vel.color.a = 1.0
        self.current_ff_vel.lifetime = rospy.Duration(0)

        # Controller drawn path
        self.drawn_path = Marker()
        self.drawn_path.header.frame_id = 'world'
        self.drawn_path.ns = "drawn_path"
        self.drawn_path.id = 4
        self.drawn_path.type = 4  # Line List.
        self.drawn_path.action = 0
        self.drawn_path.scale.x = 0.03
        self.drawn_path.color.r = 1.0
        self.drawn_path.color.g = 0.86
        self.drawn_path.color.b = 0.0
        self.drawn_path.color.a = 1.0
        self.drawn_path.lifetime = rospy.Duration(0)

        # Smoother version of the path
        self.smooth_path = Marker()
        self.smooth_path.header.frame_id = 'world'
        self.smooth_path.ns = "smooth_path"
        self.smooth_path.id = 5
        self.smooth_path.type = 4  # Line List.
        self.smooth_path.action = 0
        self.smooth_path.scale.x = 0.03
        self.smooth_path.color.r = 1.0
        self.smooth_path.color.g = 0.38
        self.smooth_path.color.b = 0.0
        self.smooth_path.color.a = 1.0
        self.smooth_path.lifetime = rospy.Duration(0)

        # Room contours
        self.room_contours = Marker()
        self.room_contours.header.frame_id = 'world'
        self.room_contours.ns = "room_contours"
        self.room_contours.id = 6
        self.room_contours.type = 4  # Line List.
        self.room_contours.action = 0
        self.room_contours.scale.x = 0.03
        self.room_contours.color.r = 0.8
        self.room_contours.color.g = 0.8
        self.room_contours.color.b = 0.8
        self.room_contours.color.a = 1.0
        self.room_contours.lifetime = rospy.Duration(0)

        # Vhat vector
        self.vhat_vector = Marker()
        self.vhat_vector.header.frame_id = 'world'
        self.vhat_vector.ns = "vhat_vector"
        self.vhat_vector.id = 7
        self.vhat_vector.type = 0  # Arrow.
        self.vhat_vector.action = 0
        self.vhat_vector.scale.x = 0.06  # shaft diameter
        self.vhat_vector.scale.y = 0.1  # head diameter
        self.vhat_vector.scale.z = 0.15  # head length
        self.vhat_vector.color.r = 1.0
        self.vhat_vector.color.g = 1.0
        self.vhat_vector.color.b = 0.3
        self.vhat_vector.color.a = 1.0
        self.vhat_vector.lifetime = rospy.Duration(0)

        # Current input vector
        self.real_input_vector = Marker()
        self.real_input_vector.header.frame_id = 'world'
        self.real_input_vector.ns = "real_input"
        self.real_input_vector.id = 8
        self.real_input_vector.type = 0  # Arrow
        self.real_input_vector.action = 0
        self.real_input_vector.scale.x = 0.06  # shaft diameter
        self.real_input_vector.scale.y = 0.1  # head diameter
        self.real_input_vector.scale.z = 0.15  # head length
        self.real_input_vector.color.r = 1.0
        self.real_input_vector.color.g = 1.0
        self.real_input_vector.color.b = 1.0
        self.real_input_vector.color.a = 1.0
        self.real_input_vector.lifetime = rospy.Duration(0)

    def reset_markers(self):
        '''Resets all Rviz markers (except for obstacles).
        '''
        # self._desired_path.points = []
        # self.trajectory_desired.publish(self._desired_path)
        self.drawn_path.points = []
        self.trajectory_drawn.publish(self.drawn_path)
        # self._real_path.points = []
        # self.trajectory_real.publish(self._real_path)
        self.smooth_path.points = []
        self.trajectory_smoothed.publish(self.smooth_path)
        self.current_ff_vel.points = [Point(), Point()]
        self.current_ff_vel_pub.publish(self.current_ff_vel)
        self.vhat_vector.points = [Point(), Point()]
        self.vhat_vector_pub.publish(self.vhat_vector)

    def publish_desired(self, x_traj, y_traj, z_traj):
        '''Publish planned x and y trajectory to topic for visualisation in
        rviz.
        '''
        # Still has to be adapted to remove old path when new goal has been
        # set.
        self._desired_path.header.stamp = rospy.get_rostime()

        # Delete points in path that have not been used before new list was
        # calculated.
        self._desired_path.points = self._desired_path.points[
                                            0:(self.old_len + self.pos_index)]

        # After a while list becomes really long so only keep last XXXX values.
        if len(self._desired_path.points) > 1000:
            self._desired_path.points = self._desired_path.points[-1000:]
        self.old_len = len(self._desired_path.points)

        # Add new calculated pos list to old one.
        new_pos = [0]*len(x_traj)
        for k in range(len(x_traj)):
            new_pos[k] = Point(x=x_traj[k], y=y_traj[k], z=z_traj[k])
        self._desired_path.points += new_pos

        self.trajectory_desired.publish(self._desired_path)

    def publish_real(self, x_pos, y_pos, z_pos):
        '''Publish real x and y trajectory to topic for visualisation in
        rviz.
        '''
        self._real_path.header.stamp = rospy.get_rostime()

        point = Point(x=x_pos, y=y_pos, z=z_pos)
        # After a while list becomes really long so only keep last XXXX values.
        if len(self._real_path.points) > 1000:
            self._real_path.points = self._real_path.points[1:] + [point]
        else:
            self._real_path.points.append(point)

        self.trajectory_real.publish(self._real_path)

    def publish_current_ff_vel(self, pos, vel):
        '''Publish current omg-tools velocity input vector where origin of the
        vector is equal to current omg-tools position.
        '''
        self.current_ff_vel.header.stamp = rospy.get_rostime()

        point_start = Point(x=pos.point.x, y=pos.point.y, z=pos.point.z)
        point_end = Point(x=(pos.point.x + vel.twist.linear.x),
                          y=(pos.point.y + vel.twist.linear.y),
                          z=(pos.point.z + vel.twist.linear.z))
        self.current_ff_vel.points = [point_start, point_end]

        self.current_ff_vel_pub.publish(self.current_ff_vel)

    def publish_real_input_vector(self, pos, vel):
        '''Publish current real input vector where origin of the
        vector is equal to current position.
        '''
        self.real_input_vector.header.stamp = rospy.get_rostime()

        point_start = Point(x=pos.x, y=pos.y, z=pos.z)
        point_end = Point(x=(pos.x + 30*vel.twist.linear.y),
                          y=(pos.y - 30*vel.twist.linear.x),
                          z=(pos.z + 30*vel.twist.linear.z))
        self.real_input_vector.points = [point_start, point_end]

        self.real_input_vector_pub.publish(self.real_input_vector)

    def publish_vhat_vector(self, pos, vel):
        '''Publish current vhat estimate from the kalman filter as a vector
        with origin equal to the current position estimate.
        '''
        self.vhat_vector.header.stamp = rospy.get_rostime()

        point_start = Point(x=pos.x, y=pos.y, z=pos.z)
        point_end = Point(x=(pos.x + vel.x),
                          y=(pos.y + vel.y),
                          z=(pos.z + vel.z))
        self.vhat_vector.points = [point_start, point_end]

        self.vhat_vector_pub.publish(self.vhat_vector)

    def publish_obst_room(self, empty):
        '''Publish static obstacles as well as the boundary of the room.
        '''
        # Delete markers
        marker = Marker()
        marker.ns = "obstacles"
        marker.action = 3  # 3 deletes markers
        self.rviz_obst.markers = [marker]
        self.obst_pub.publish(self.rviz_obst)

        # self.rviz_obst = MarkerArray()
        # self.obst_pub.publish(self.rviz_obst)
        j = 0
        window_plate = 0
        for i, obstacle in enumerate(self.static_obst):
            # Marker setup
            if obstacle.obst_type.data == 'slalom plate':
                j += 1
                d = obstacle.direction
                green_marker = Marker()
                red_marker = Marker()
                green_marker.header.frame_id = 'world'
                red_marker.header.frame_id = 'world'
                green_marker.ns = "obstacles"
                red_marker.ns = "obstacles"
                green_marker.id = i+j+7
                red_marker.id = i+(j-1)+7
                green_marker.type = 3  # Cylinder
                red_marker.type = 3  # Cylinder
                green_marker.action = 0
                red_marker.action = 0
                green_marker.scale.x = obstacle.shape[2]  # x-diameter
                green_marker.scale.y = obstacle.shape[2]  # y-diameter
                green_marker.scale.z = self.room_height  # height
                red_marker.scale.x = obstacle.shape[2]  # x-diameter
                red_marker.scale.y = obstacle.shape[2]  # y-diameter
                red_marker.scale.z = self.room_height  # height

                green_marker.color.r = 0.0
                green_marker.color.g = 1.0
                green_marker.color.b = 0.0
                green_marker.color.a = 0.5
                red_marker.color.r = 1.0
                red_marker.color.g = 0.0
                red_marker.color.b = 0.0
                red_marker.color.a = 0.5
                green_marker.lifetime = rospy.Duration(0)
                red_marker.lifetime = rospy.Duration(0)

                green_marker.pose.position = Point(
                                  x=obstacle.edge[0],
                                  y=obstacle.edge[1] + d*0.5*obstacle.shape[2],
                                  z=obstacle.edge[2])
                red_marker.pose.position = Point(
                                  x=obstacle.edge[0],
                                  y=obstacle.edge[1] + d*1.5*obstacle.shape[2],
                                  z=obstacle.edge[2])
                green_marker.header.stamp = rospy.get_rostime()
                red_marker.header.stamp = rospy.get_rostime()

                # Append marker to marker array:
                self.rviz_obst.markers.append(green_marker)
                self.rviz_obst.markers.append(red_marker)

            elif obstacle.obst_type.data == 'window plate':
                obstacle_marker = Marker()
                obstacle_marker.header.frame_id = 'world'
                obstacle_marker.ns = "obstacles"
                obstacle_marker.id = i+j+7
                obstacle_marker.action = 0
                obstacle_marker.color.r = 0.188
                obstacle_marker.color.g = 0.525
                obstacle_marker.color.b = 0.82
                obstacle_marker.color.a = 0.5
                obstacle_marker.lifetime = rospy.Duration(0)

                obstacle_marker.type = 1  # Cuboid
                obstacle_marker.scale.x = obstacle.shape[2]  # thickness
                # shape = [height, width, thickness]
                # Window plates come by 4. You need the dimensions of two
                # overlapping plates to know the edge of the window hole
                # corresponding to the current plate.
                window_plate = i % 4
                if window_plate == 0:
                    left = obstacle
                    up = self.static_obst[i+2]
                    down = self.static_obst[i+3]
                    pose = [left.pose[0],
                            -(self.room_depth/2. - left.shape[1]
                              + left.shape[2]/2.),
                            ((self.room_height - up.shape[0]) +
                             down.shape[0])/2.]
                    obstacle_marker.pose.position = Point(x=pose[0],
                                                          y=pose[1],
                                                          z=pose[2])

                    obstacle_marker.scale.y = left.shape[2]
                    obstacle_marker.scale.z = (
                        self.room_height - (up.shape[0] + down.shape[0]))
                elif window_plate == 1:
                    right = obstacle
                    up = self.static_obst[i+1]
                    down = self.static_obst[i+2]
                    pose = [right.pose[0],
                            (self.room_depth/2. - right.shape[1]
                             + right.shape[2]/2.),
                            ((self.room_height - up.shape[0]) +
                             down.shape[0])/2.]
                    obstacle_marker.pose.position = Point(x=pose[0],
                                                          y=pose[1],
                                                          z=pose[2])
                    obstacle_marker.scale.y = right.shape[2]
                    obstacle_marker.scale.z = (
                        self.room_height - (up.shape[0] + down.shape[0]))
                elif window_plate == 2:
                    left = self.static_obst[i-2]
                    right = self.static_obst[i-1]
                    up = obstacle
                    pose = [up.pose[0],
                            (left.shape[1] - right.shape[1])/2.,
                            (self.room_height - up.shape[0] + up.shape[2]/2.)]
                    obstacle_marker.pose.position = Point(x=pose[0],
                                                          y=pose[1],
                                                          z=pose[2])
                    obstacle_marker.scale.y = (
                        self.room_depth - (left.shape[1] + right.shape[1])
                        + 2*up.shape[2])
                    obstacle_marker.scale.z = up.shape[2]
                elif window_plate == 3:
                    left = self.static_obst[i-3]
                    right = self.static_obst[i-2]
                    down = obstacle
                    pose = [down.pose[0],
                            (left.shape[1] - right.shape[1])/2.,
                            down.shape[0] - down.shape[2]/2.]
                    obstacle_marker.pose.position = Point(x=pose[0],
                                                          y=pose[1],
                                                          z=pose[2])
                    obstacle_marker.scale.y = (
                        self.room_depth - (left.shape[1] + right.shape[1])
                        + 2*down.shape[2])
                    obstacle_marker.scale.z = down.shape[2]

                obstacle_marker.header.stamp = rospy.get_rostime()
                # Append marker to marker array:
                self.rviz_obst.markers.append(obstacle_marker)

            else:
                obstacle_marker = Marker()
                obstacle_marker.header.frame_id = 'world'
                obstacle_marker.ns = "obstacles"
                obstacle_marker.id = i+j+7
                obstacle_marker.action = 0
                obstacle_marker.color.r = 1.0
                obstacle_marker.color.g = 1.0
                obstacle_marker.color.b = 1.0
                obstacle_marker.color.a = 0.5
                obstacle_marker.lifetime = rospy.Duration(0)

                if obstacle.obst_type.data == 'inf_cylinder':
                    obstacle_marker.type = 3  # Cylinder
                    obstacle.shape = [obstacle.shape[0], self.room_height]
                    obstacle.pose = [obstacle.pose[0],
                                     obstacle.pose[1],
                                     self.room_height/2]
                    obstacle_marker.scale.x = obstacle.shape[0] * 2  # x-diam
                    obstacle_marker.scale.y = obstacle.shape[0] * 2  # y-diam
                    obstacle_marker.scale.z = obstacle.shape[1]  # height
                elif obstacle.obst_type.data == 'hexagon':
                    obstacle_marker.type = 3  # Cylinder
                    obstacle_marker.scale.x = obstacle.shape[0] * 2  # x-diam
                    obstacle_marker.scale.y = obstacle.shape[0] * 2  # y-diam
                    obstacle_marker.scale.z = obstacle.shape[1]  # height
                elif obstacle.obst_type.data == 'plate':
                    obstacle_marker.type = 1  # Cuboid
                    obstacle_marker.scale.x = obstacle.shape[2]  # thickness
                    obstacle_marker.scale.y = obstacle.shape[1]  # width
                    obstacle_marker.scale.z = obstacle.shape[0]  # height
                    quaternion = tf.transformations.quaternion_from_euler(
                                                    0., 0., obstacle.direction)
                    obstacle_marker.pose.orientation.x = quaternion[0]
                    obstacle_marker.pose.orientation.y = quaternion[1]
                    obstacle_marker.pose.orientation.z = quaternion[2]
                    obstacle_marker.pose.orientation.w = quaternion[3]

                obstacle_marker.pose.position = Point(x=obstacle.pose[0],
                                                      y=obstacle.pose[1],
                                                      z=obstacle.pose[2])
                obstacle_marker.header.stamp = rospy.get_rostime()

                # Append marker to marker array:
                self.rviz_obst.markers.append(obstacle_marker)

        self.reset_markers()
        self.obst_pub.publish(self.rviz_obst)
        self.draw_room_contours()

    def draw_ctrl_path(self):
        '''Publish real x and y trajectory to topic for visualisation in
        rviz.
        '''
        self.drawn_path.header.stamp = rospy.get_rostime()

        self.drawn_path.points = []

        for index in range(len(self.drawn_pos_x)):
            point = Point(x=self.drawn_pos_x[index],
                          y=self.drawn_pos_y[index],
                          z=self.drawn_pos_z[index])
            self.drawn_path.points.append(point)

        self.trajectory_drawn.publish(self.drawn_path)

    def draw_smoothed_path(self):
        '''Publish the smoothed x and y trajectory to topic for visualisation
        in rviz.
        '''
        self.smooth_path.header.stamp = rospy.get_rostime()
        self.smooth_path.points = []

        for index in range(len(self.drawn_pos_x)):
            point = Point(x=self.drawn_pos_x[index],
                          y=self.drawn_pos_y[index],
                          z=self.drawn_pos_z[index])
            self.smooth_path.points.append(point)

        self.trajectory_smoothed.publish(self.smooth_path)

    def draw_room_contours(self):
        '''Publish the edges of the room for visualization in rviz.
        '''
        self.room_contours.header.stamp = rospy.get_rostime()

        bottom_left = Point(x=-self.room_width/2.,
                            y=-self.room_depth/2.)
        bottom_right = Point(x=self.room_width/2.,
                             y=-self.room_depth/2.)
        top_right = Point(x=self.room_width/2.,
                          y=self.room_depth/2.)
        top_left = Point(x=-self.room_width/2.,
                         y=self.room_depth/2.)
        corners = [bottom_left, bottom_right, top_right, top_left, bottom_left]
        for point in corners:
            self.room_contours.points.append(point)

        self.draw_room.publish(self.room_contours)


if __name__ == '__main__':
    controller = Controller()
    controller.start()
